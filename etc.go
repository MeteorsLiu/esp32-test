package main

import "llgo-test/volatile"

// Constants for RTC_CNTL: Real-Time Clock Control
const (
	// OPTIONS0
	// Position of SW_STALL_APPCPU_C0 field.
	RTC_CNTL_OPTIONS0_SW_STALL_APPCPU_C0_Pos = 0x0
	// Bit mask of SW_STALL_APPCPU_C0 field.
	RTC_CNTL_OPTIONS0_SW_STALL_APPCPU_C0_Msk = 0x3
	// Position of SW_STALL_PROCPU_C0 field.
	RTC_CNTL_OPTIONS0_SW_STALL_PROCPU_C0_Pos = 0x2
	// Bit mask of SW_STALL_PROCPU_C0 field.
	RTC_CNTL_OPTIONS0_SW_STALL_PROCPU_C0_Msk = 0xc
	// Position of SW_APPCPU_RST field.
	RTC_CNTL_OPTIONS0_SW_APPCPU_RST_Pos = 0x4
	// Bit mask of SW_APPCPU_RST field.
	RTC_CNTL_OPTIONS0_SW_APPCPU_RST_Msk = 0x10
	// Bit SW_APPCPU_RST.
	RTC_CNTL_OPTIONS0_SW_APPCPU_RST = 0x10
	// Position of SW_PROCPU_RST field.
	RTC_CNTL_OPTIONS0_SW_PROCPU_RST_Pos = 0x5
	// Bit mask of SW_PROCPU_RST field.
	RTC_CNTL_OPTIONS0_SW_PROCPU_RST_Msk = 0x20
	// Bit SW_PROCPU_RST.
	RTC_CNTL_OPTIONS0_SW_PROCPU_RST = 0x20
	// Position of BB_I2C_FORCE_PD field.
	RTC_CNTL_OPTIONS0_BB_I2C_FORCE_PD_Pos = 0x6
	// Bit mask of BB_I2C_FORCE_PD field.
	RTC_CNTL_OPTIONS0_BB_I2C_FORCE_PD_Msk = 0x40
	// Bit BB_I2C_FORCE_PD.
	RTC_CNTL_OPTIONS0_BB_I2C_FORCE_PD = 0x40
	// Position of BB_I2C_FORCE_PU field.
	RTC_CNTL_OPTIONS0_BB_I2C_FORCE_PU_Pos = 0x7
	// Bit mask of BB_I2C_FORCE_PU field.
	RTC_CNTL_OPTIONS0_BB_I2C_FORCE_PU_Msk = 0x80
	// Bit BB_I2C_FORCE_PU.
	RTC_CNTL_OPTIONS0_BB_I2C_FORCE_PU = 0x80
	// Position of BBPLL_I2C_FORCE_PD field.
	RTC_CNTL_OPTIONS0_BBPLL_I2C_FORCE_PD_Pos = 0x8
	// Bit mask of BBPLL_I2C_FORCE_PD field.
	RTC_CNTL_OPTIONS0_BBPLL_I2C_FORCE_PD_Msk = 0x100
	// Bit BBPLL_I2C_FORCE_PD.
	RTC_CNTL_OPTIONS0_BBPLL_I2C_FORCE_PD = 0x100
	// Position of BBPLL_I2C_FORCE_PU field.
	RTC_CNTL_OPTIONS0_BBPLL_I2C_FORCE_PU_Pos = 0x9
	// Bit mask of BBPLL_I2C_FORCE_PU field.
	RTC_CNTL_OPTIONS0_BBPLL_I2C_FORCE_PU_Msk = 0x200
	// Bit BBPLL_I2C_FORCE_PU.
	RTC_CNTL_OPTIONS0_BBPLL_I2C_FORCE_PU = 0x200
	// Position of BBPLL_FORCE_PD field.
	RTC_CNTL_OPTIONS0_BBPLL_FORCE_PD_Pos = 0xa
	// Bit mask of BBPLL_FORCE_PD field.
	RTC_CNTL_OPTIONS0_BBPLL_FORCE_PD_Msk = 0x400
	// Bit BBPLL_FORCE_PD.
	RTC_CNTL_OPTIONS0_BBPLL_FORCE_PD = 0x400
	// Position of BBPLL_FORCE_PU field.
	RTC_CNTL_OPTIONS0_BBPLL_FORCE_PU_Pos = 0xb
	// Bit mask of BBPLL_FORCE_PU field.
	RTC_CNTL_OPTIONS0_BBPLL_FORCE_PU_Msk = 0x800
	// Bit BBPLL_FORCE_PU.
	RTC_CNTL_OPTIONS0_BBPLL_FORCE_PU = 0x800
	// Position of XTL_FORCE_PD field.
	RTC_CNTL_OPTIONS0_XTL_FORCE_PD_Pos = 0xc
	// Bit mask of XTL_FORCE_PD field.
	RTC_CNTL_OPTIONS0_XTL_FORCE_PD_Msk = 0x1000
	// Bit XTL_FORCE_PD.
	RTC_CNTL_OPTIONS0_XTL_FORCE_PD = 0x1000
	// Position of XTL_FORCE_PU field.
	RTC_CNTL_OPTIONS0_XTL_FORCE_PU_Pos = 0xd
	// Bit mask of XTL_FORCE_PU field.
	RTC_CNTL_OPTIONS0_XTL_FORCE_PU_Msk = 0x2000
	// Bit XTL_FORCE_PU.
	RTC_CNTL_OPTIONS0_XTL_FORCE_PU = 0x2000
	// Position of BIAS_SLEEP_FOLW_8M field.
	RTC_CNTL_OPTIONS0_BIAS_SLEEP_FOLW_8M_Pos = 0xe
	// Bit mask of BIAS_SLEEP_FOLW_8M field.
	RTC_CNTL_OPTIONS0_BIAS_SLEEP_FOLW_8M_Msk = 0x4000
	// Bit BIAS_SLEEP_FOLW_8M.
	RTC_CNTL_OPTIONS0_BIAS_SLEEP_FOLW_8M = 0x4000
	// Position of BIAS_FORCE_SLEEP field.
	RTC_CNTL_OPTIONS0_BIAS_FORCE_SLEEP_Pos = 0xf
	// Bit mask of BIAS_FORCE_SLEEP field.
	RTC_CNTL_OPTIONS0_BIAS_FORCE_SLEEP_Msk = 0x8000
	// Bit BIAS_FORCE_SLEEP.
	RTC_CNTL_OPTIONS0_BIAS_FORCE_SLEEP = 0x8000
	// Position of BIAS_FORCE_NOSLEEP field.
	RTC_CNTL_OPTIONS0_BIAS_FORCE_NOSLEEP_Pos = 0x10
	// Bit mask of BIAS_FORCE_NOSLEEP field.
	RTC_CNTL_OPTIONS0_BIAS_FORCE_NOSLEEP_Msk = 0x10000
	// Bit BIAS_FORCE_NOSLEEP.
	RTC_CNTL_OPTIONS0_BIAS_FORCE_NOSLEEP = 0x10000
	// Position of BIAS_I2C_FOLW_8M field.
	RTC_CNTL_OPTIONS0_BIAS_I2C_FOLW_8M_Pos = 0x11
	// Bit mask of BIAS_I2C_FOLW_8M field.
	RTC_CNTL_OPTIONS0_BIAS_I2C_FOLW_8M_Msk = 0x20000
	// Bit BIAS_I2C_FOLW_8M.
	RTC_CNTL_OPTIONS0_BIAS_I2C_FOLW_8M = 0x20000
	// Position of BIAS_I2C_FORCE_PD field.
	RTC_CNTL_OPTIONS0_BIAS_I2C_FORCE_PD_Pos = 0x12
	// Bit mask of BIAS_I2C_FORCE_PD field.
	RTC_CNTL_OPTIONS0_BIAS_I2C_FORCE_PD_Msk = 0x40000
	// Bit BIAS_I2C_FORCE_PD.
	RTC_CNTL_OPTIONS0_BIAS_I2C_FORCE_PD = 0x40000
	// Position of BIAS_I2C_FORCE_PU field.
	RTC_CNTL_OPTIONS0_BIAS_I2C_FORCE_PU_Pos = 0x13
	// Bit mask of BIAS_I2C_FORCE_PU field.
	RTC_CNTL_OPTIONS0_BIAS_I2C_FORCE_PU_Msk = 0x80000
	// Bit BIAS_I2C_FORCE_PU.
	RTC_CNTL_OPTIONS0_BIAS_I2C_FORCE_PU = 0x80000
	// Position of BIAS_CORE_FOLW_8M field.
	RTC_CNTL_OPTIONS0_BIAS_CORE_FOLW_8M_Pos = 0x14
	// Bit mask of BIAS_CORE_FOLW_8M field.
	RTC_CNTL_OPTIONS0_BIAS_CORE_FOLW_8M_Msk = 0x100000
	// Bit BIAS_CORE_FOLW_8M.
	RTC_CNTL_OPTIONS0_BIAS_CORE_FOLW_8M = 0x100000
	// Position of BIAS_CORE_FORCE_PD field.
	RTC_CNTL_OPTIONS0_BIAS_CORE_FORCE_PD_Pos = 0x15
	// Bit mask of BIAS_CORE_FORCE_PD field.
	RTC_CNTL_OPTIONS0_BIAS_CORE_FORCE_PD_Msk = 0x200000
	// Bit BIAS_CORE_FORCE_PD.
	RTC_CNTL_OPTIONS0_BIAS_CORE_FORCE_PD = 0x200000
	// Position of BIAS_CORE_FORCE_PU field.
	RTC_CNTL_OPTIONS0_BIAS_CORE_FORCE_PU_Pos = 0x16
	// Bit mask of BIAS_CORE_FORCE_PU field.
	RTC_CNTL_OPTIONS0_BIAS_CORE_FORCE_PU_Msk = 0x400000
	// Bit BIAS_CORE_FORCE_PU.
	RTC_CNTL_OPTIONS0_BIAS_CORE_FORCE_PU = 0x400000
	// Position of XTL_FORCE_ISO field.
	RTC_CNTL_OPTIONS0_XTL_FORCE_ISO_Pos = 0x17
	// Bit mask of XTL_FORCE_ISO field.
	RTC_CNTL_OPTIONS0_XTL_FORCE_ISO_Msk = 0x800000
	// Bit XTL_FORCE_ISO.
	RTC_CNTL_OPTIONS0_XTL_FORCE_ISO = 0x800000
	// Position of PLL_FORCE_ISO field.
	RTC_CNTL_OPTIONS0_PLL_FORCE_ISO_Pos = 0x18
	// Bit mask of PLL_FORCE_ISO field.
	RTC_CNTL_OPTIONS0_PLL_FORCE_ISO_Msk = 0x1000000
	// Bit PLL_FORCE_ISO.
	RTC_CNTL_OPTIONS0_PLL_FORCE_ISO = 0x1000000
	// Position of ANALOG_FORCE_ISO field.
	RTC_CNTL_OPTIONS0_ANALOG_FORCE_ISO_Pos = 0x19
	// Bit mask of ANALOG_FORCE_ISO field.
	RTC_CNTL_OPTIONS0_ANALOG_FORCE_ISO_Msk = 0x2000000
	// Bit ANALOG_FORCE_ISO.
	RTC_CNTL_OPTIONS0_ANALOG_FORCE_ISO = 0x2000000
	// Position of XTL_FORCE_NOISO field.
	RTC_CNTL_OPTIONS0_XTL_FORCE_NOISO_Pos = 0x1a
	// Bit mask of XTL_FORCE_NOISO field.
	RTC_CNTL_OPTIONS0_XTL_FORCE_NOISO_Msk = 0x4000000
	// Bit XTL_FORCE_NOISO.
	RTC_CNTL_OPTIONS0_XTL_FORCE_NOISO = 0x4000000
	// Position of PLL_FORCE_NOISO field.
	RTC_CNTL_OPTIONS0_PLL_FORCE_NOISO_Pos = 0x1b
	// Bit mask of PLL_FORCE_NOISO field.
	RTC_CNTL_OPTIONS0_PLL_FORCE_NOISO_Msk = 0x8000000
	// Bit PLL_FORCE_NOISO.
	RTC_CNTL_OPTIONS0_PLL_FORCE_NOISO = 0x8000000
	// Position of ANALOG_FORCE_NOISO field.
	RTC_CNTL_OPTIONS0_ANALOG_FORCE_NOISO_Pos = 0x1c
	// Bit mask of ANALOG_FORCE_NOISO field.
	RTC_CNTL_OPTIONS0_ANALOG_FORCE_NOISO_Msk = 0x10000000
	// Bit ANALOG_FORCE_NOISO.
	RTC_CNTL_OPTIONS0_ANALOG_FORCE_NOISO = 0x10000000
	// Position of DG_WRAP_FORCE_RST field.
	RTC_CNTL_OPTIONS0_DG_WRAP_FORCE_RST_Pos = 0x1d
	// Bit mask of DG_WRAP_FORCE_RST field.
	RTC_CNTL_OPTIONS0_DG_WRAP_FORCE_RST_Msk = 0x20000000
	// Bit DG_WRAP_FORCE_RST.
	RTC_CNTL_OPTIONS0_DG_WRAP_FORCE_RST = 0x20000000
	// Position of DG_WRAP_FORCE_NORST field.
	RTC_CNTL_OPTIONS0_DG_WRAP_FORCE_NORST_Pos = 0x1e
	// Bit mask of DG_WRAP_FORCE_NORST field.
	RTC_CNTL_OPTIONS0_DG_WRAP_FORCE_NORST_Msk = 0x40000000
	// Bit DG_WRAP_FORCE_NORST.
	RTC_CNTL_OPTIONS0_DG_WRAP_FORCE_NORST = 0x40000000
	// Position of SW_SYS_RST field.
	RTC_CNTL_OPTIONS0_SW_SYS_RST_Pos = 0x1f
	// Bit mask of SW_SYS_RST field.
	RTC_CNTL_OPTIONS0_SW_SYS_RST_Msk = 0x80000000
	// Bit SW_SYS_RST.
	RTC_CNTL_OPTIONS0_SW_SYS_RST = 0x80000000

	// SLP_TIMER0
	// Position of SLP_VAL_LO field.
	RTC_CNTL_SLP_TIMER0_SLP_VAL_LO_Pos = 0x0
	// Bit mask of SLP_VAL_LO field.
	RTC_CNTL_SLP_TIMER0_SLP_VAL_LO_Msk = 0xffffffff

	// SLP_TIMER1
	// Position of SLP_VAL_HI field.
	RTC_CNTL_SLP_TIMER1_SLP_VAL_HI_Pos = 0x0
	// Bit mask of SLP_VAL_HI field.
	RTC_CNTL_SLP_TIMER1_SLP_VAL_HI_Msk = 0xffff
	// Position of MAIN_TIMER_ALARM_EN field.
	RTC_CNTL_SLP_TIMER1_MAIN_TIMER_ALARM_EN_Pos = 0x10
	// Bit mask of MAIN_TIMER_ALARM_EN field.
	RTC_CNTL_SLP_TIMER1_MAIN_TIMER_ALARM_EN_Msk = 0x10000
	// Bit MAIN_TIMER_ALARM_EN.
	RTC_CNTL_SLP_TIMER1_MAIN_TIMER_ALARM_EN = 0x10000

	// TIME_UPDATE
	// Position of TIME_VALID field.
	RTC_CNTL_TIME_UPDATE_TIME_VALID_Pos = 0x1e
	// Bit mask of TIME_VALID field.
	RTC_CNTL_TIME_UPDATE_TIME_VALID_Msk = 0x40000000
	// Bit TIME_VALID.
	RTC_CNTL_TIME_UPDATE_TIME_VALID = 0x40000000
	// Position of TIME_UPDATE field.
	RTC_CNTL_TIME_UPDATE_TIME_UPDATE_Pos = 0x1f
	// Bit mask of TIME_UPDATE field.
	RTC_CNTL_TIME_UPDATE_TIME_UPDATE_Msk = 0x80000000
	// Bit TIME_UPDATE.
	RTC_CNTL_TIME_UPDATE_TIME_UPDATE = 0x80000000

	// TIME0
	// Position of TIME_LO field.
	RTC_CNTL_TIME0_TIME_LO_Pos = 0x0
	// Bit mask of TIME_LO field.
	RTC_CNTL_TIME0_TIME_LO_Msk = 0xffffffff

	// TIME1
	// Position of TIME_HI field.
	RTC_CNTL_TIME1_TIME_HI_Pos = 0x0
	// Bit mask of TIME_HI field.
	RTC_CNTL_TIME1_TIME_HI_Msk = 0xffff

	// STATE0
	// Position of TOUCH_WAKEUP_FORCE_EN field.
	RTC_CNTL_STATE0_TOUCH_WAKEUP_FORCE_EN_Pos = 0x14
	// Bit mask of TOUCH_WAKEUP_FORCE_EN field.
	RTC_CNTL_STATE0_TOUCH_WAKEUP_FORCE_EN_Msk = 0x100000
	// Bit TOUCH_WAKEUP_FORCE_EN.
	RTC_CNTL_STATE0_TOUCH_WAKEUP_FORCE_EN = 0x100000
	// Position of ULP_CP_WAKEUP_FORCE_EN field.
	RTC_CNTL_STATE0_ULP_CP_WAKEUP_FORCE_EN_Pos = 0x15
	// Bit mask of ULP_CP_WAKEUP_FORCE_EN field.
	RTC_CNTL_STATE0_ULP_CP_WAKEUP_FORCE_EN_Msk = 0x200000
	// Bit ULP_CP_WAKEUP_FORCE_EN.
	RTC_CNTL_STATE0_ULP_CP_WAKEUP_FORCE_EN = 0x200000
	// Position of APB2RTC_BRIDGE_SEL field.
	RTC_CNTL_STATE0_APB2RTC_BRIDGE_SEL_Pos = 0x16
	// Bit mask of APB2RTC_BRIDGE_SEL field.
	RTC_CNTL_STATE0_APB2RTC_BRIDGE_SEL_Msk = 0x400000
	// Bit APB2RTC_BRIDGE_SEL.
	RTC_CNTL_STATE0_APB2RTC_BRIDGE_SEL = 0x400000
	// Position of TOUCH_SLP_TIMER_EN field.
	RTC_CNTL_STATE0_TOUCH_SLP_TIMER_EN_Pos = 0x17
	// Bit mask of TOUCH_SLP_TIMER_EN field.
	RTC_CNTL_STATE0_TOUCH_SLP_TIMER_EN_Msk = 0x800000
	// Bit TOUCH_SLP_TIMER_EN.
	RTC_CNTL_STATE0_TOUCH_SLP_TIMER_EN = 0x800000
	// Position of ULP_CP_SLP_TIMER_EN field.
	RTC_CNTL_STATE0_ULP_CP_SLP_TIMER_EN_Pos = 0x18
	// Bit mask of ULP_CP_SLP_TIMER_EN field.
	RTC_CNTL_STATE0_ULP_CP_SLP_TIMER_EN_Msk = 0x1000000
	// Bit ULP_CP_SLP_TIMER_EN.
	RTC_CNTL_STATE0_ULP_CP_SLP_TIMER_EN = 0x1000000
	// Position of SDIO_ACTIVE_IND field.
	RTC_CNTL_STATE0_SDIO_ACTIVE_IND_Pos = 0x1c
	// Bit mask of SDIO_ACTIVE_IND field.
	RTC_CNTL_STATE0_SDIO_ACTIVE_IND_Msk = 0x10000000
	// Bit SDIO_ACTIVE_IND.
	RTC_CNTL_STATE0_SDIO_ACTIVE_IND = 0x10000000
	// Position of SLP_WAKEUP field.
	RTC_CNTL_STATE0_SLP_WAKEUP_Pos = 0x1d
	// Bit mask of SLP_WAKEUP field.
	RTC_CNTL_STATE0_SLP_WAKEUP_Msk = 0x20000000
	// Bit SLP_WAKEUP.
	RTC_CNTL_STATE0_SLP_WAKEUP = 0x20000000
	// Position of SLP_REJECT field.
	RTC_CNTL_STATE0_SLP_REJECT_Pos = 0x1e
	// Bit mask of SLP_REJECT field.
	RTC_CNTL_STATE0_SLP_REJECT_Msk = 0x40000000
	// Bit SLP_REJECT.
	RTC_CNTL_STATE0_SLP_REJECT = 0x40000000
	// Position of SLEEP_EN field.
	RTC_CNTL_STATE0_SLEEP_EN_Pos = 0x1f
	// Bit mask of SLEEP_EN field.
	RTC_CNTL_STATE0_SLEEP_EN_Msk = 0x80000000
	// Bit SLEEP_EN.
	RTC_CNTL_STATE0_SLEEP_EN = 0x80000000

	// TIMER1
	// Position of CPU_STALL_EN field.
	RTC_CNTL_TIMER1_CPU_STALL_EN_Pos = 0x0
	// Bit mask of CPU_STALL_EN field.
	RTC_CNTL_TIMER1_CPU_STALL_EN_Msk = 0x1
	// Bit CPU_STALL_EN.
	RTC_CNTL_TIMER1_CPU_STALL_EN = 0x1
	// Position of CPU_STALL_WAIT field.
	RTC_CNTL_TIMER1_CPU_STALL_WAIT_Pos = 0x1
	// Bit mask of CPU_STALL_WAIT field.
	RTC_CNTL_TIMER1_CPU_STALL_WAIT_Msk = 0x3e
	// Position of CK8M_WAIT field.
	RTC_CNTL_TIMER1_CK8M_WAIT_Pos = 0x6
	// Bit mask of CK8M_WAIT field.
	RTC_CNTL_TIMER1_CK8M_WAIT_Msk = 0x3fc0
	// Position of XTL_BUF_WAIT field.
	RTC_CNTL_TIMER1_XTL_BUF_WAIT_Pos = 0xe
	// Bit mask of XTL_BUF_WAIT field.
	RTC_CNTL_TIMER1_XTL_BUF_WAIT_Msk = 0xffc000
	// Position of PLL_BUF_WAIT field.
	RTC_CNTL_TIMER1_PLL_BUF_WAIT_Pos = 0x18
	// Bit mask of PLL_BUF_WAIT field.
	RTC_CNTL_TIMER1_PLL_BUF_WAIT_Msk = 0xff000000

	// TIMER2
	// Position of ULPCP_TOUCH_START_WAIT field.
	RTC_CNTL_TIMER2_ULPCP_TOUCH_START_WAIT_Pos = 0xf
	// Bit mask of ULPCP_TOUCH_START_WAIT field.
	RTC_CNTL_TIMER2_ULPCP_TOUCH_START_WAIT_Msk = 0xff8000
	// Position of MIN_TIME_CK8M_OFF field.
	RTC_CNTL_TIMER2_MIN_TIME_CK8M_OFF_Pos = 0x18
	// Bit mask of MIN_TIME_CK8M_OFF field.
	RTC_CNTL_TIMER2_MIN_TIME_CK8M_OFF_Msk = 0xff000000

	// TIMER3
	// Position of WIFI_WAIT_TIMER field.
	RTC_CNTL_TIMER3_WIFI_WAIT_TIMER_Pos = 0x0
	// Bit mask of WIFI_WAIT_TIMER field.
	RTC_CNTL_TIMER3_WIFI_WAIT_TIMER_Msk = 0x1ff
	// Position of WIFI_POWERUP_TIMER field.
	RTC_CNTL_TIMER3_WIFI_POWERUP_TIMER_Pos = 0x9
	// Bit mask of WIFI_POWERUP_TIMER field.
	RTC_CNTL_TIMER3_WIFI_POWERUP_TIMER_Msk = 0xfe00
	// Position of ROM_RAM_WAIT_TIMER field.
	RTC_CNTL_TIMER3_ROM_RAM_WAIT_TIMER_Pos = 0x10
	// Bit mask of ROM_RAM_WAIT_TIMER field.
	RTC_CNTL_TIMER3_ROM_RAM_WAIT_TIMER_Msk = 0x1ff0000
	// Position of ROM_RAM_POWERUP_TIMER field.
	RTC_CNTL_TIMER3_ROM_RAM_POWERUP_TIMER_Pos = 0x19
	// Bit mask of ROM_RAM_POWERUP_TIMER field.
	RTC_CNTL_TIMER3_ROM_RAM_POWERUP_TIMER_Msk = 0xfe000000

	// TIMER4
	// Position of WAIT_TIMER field.
	RTC_CNTL_TIMER4_WAIT_TIMER_Pos = 0x0
	// Bit mask of WAIT_TIMER field.
	RTC_CNTL_TIMER4_WAIT_TIMER_Msk = 0x1ff
	// Position of POWERUP_TIMER field.
	RTC_CNTL_TIMER4_POWERUP_TIMER_Pos = 0x9
	// Bit mask of POWERUP_TIMER field.
	RTC_CNTL_TIMER4_POWERUP_TIMER_Msk = 0xfe00
	// Position of DG_WRAP_WAIT_TIMER field.
	RTC_CNTL_TIMER4_DG_WRAP_WAIT_TIMER_Pos = 0x10
	// Bit mask of DG_WRAP_WAIT_TIMER field.
	RTC_CNTL_TIMER4_DG_WRAP_WAIT_TIMER_Msk = 0x1ff0000
	// Position of DG_WRAP_POWERUP_TIMER field.
	RTC_CNTL_TIMER4_DG_WRAP_POWERUP_TIMER_Pos = 0x19
	// Bit mask of DG_WRAP_POWERUP_TIMER field.
	RTC_CNTL_TIMER4_DG_WRAP_POWERUP_TIMER_Msk = 0xfe000000

	// TIMER5
	// Position of ULP_CP_SUBTIMER_PREDIV field.
	RTC_CNTL_TIMER5_ULP_CP_SUBTIMER_PREDIV_Pos = 0x0
	// Bit mask of ULP_CP_SUBTIMER_PREDIV field.
	RTC_CNTL_TIMER5_ULP_CP_SUBTIMER_PREDIV_Msk = 0xff
	// Position of MIN_SLP_VAL field.
	RTC_CNTL_TIMER5_MIN_SLP_VAL_Pos = 0x8
	// Bit mask of MIN_SLP_VAL field.
	RTC_CNTL_TIMER5_MIN_SLP_VAL_Msk = 0xff00
	// Position of RTCMEM_WAIT_TIMER field.
	RTC_CNTL_TIMER5_RTCMEM_WAIT_TIMER_Pos = 0x10
	// Bit mask of RTCMEM_WAIT_TIMER field.
	RTC_CNTL_TIMER5_RTCMEM_WAIT_TIMER_Msk = 0x1ff0000
	// Position of RTCMEM_POWERUP_TIMER field.
	RTC_CNTL_TIMER5_RTCMEM_POWERUP_TIMER_Pos = 0x19
	// Bit mask of RTCMEM_POWERUP_TIMER field.
	RTC_CNTL_TIMER5_RTCMEM_POWERUP_TIMER_Msk = 0xfe000000

	// ANA_CONF
	// Position of PLLA_FORCE_PD field.
	RTC_CNTL_ANA_CONF_PLLA_FORCE_PD_Pos = 0x17
	// Bit mask of PLLA_FORCE_PD field.
	RTC_CNTL_ANA_CONF_PLLA_FORCE_PD_Msk = 0x800000
	// Bit PLLA_FORCE_PD.
	RTC_CNTL_ANA_CONF_PLLA_FORCE_PD = 0x800000
	// Position of PLLA_FORCE_PU field.
	RTC_CNTL_ANA_CONF_PLLA_FORCE_PU_Pos = 0x18
	// Bit mask of PLLA_FORCE_PU field.
	RTC_CNTL_ANA_CONF_PLLA_FORCE_PU_Msk = 0x1000000
	// Bit PLLA_FORCE_PU.
	RTC_CNTL_ANA_CONF_PLLA_FORCE_PU = 0x1000000
	// Position of BBPLL_CAL_SLP_START field.
	RTC_CNTL_ANA_CONF_BBPLL_CAL_SLP_START_Pos = 0x19
	// Bit mask of BBPLL_CAL_SLP_START field.
	RTC_CNTL_ANA_CONF_BBPLL_CAL_SLP_START_Msk = 0x2000000
	// Bit BBPLL_CAL_SLP_START.
	RTC_CNTL_ANA_CONF_BBPLL_CAL_SLP_START = 0x2000000
	// Position of PVTMON_PU field.
	RTC_CNTL_ANA_CONF_PVTMON_PU_Pos = 0x1a
	// Bit mask of PVTMON_PU field.
	RTC_CNTL_ANA_CONF_PVTMON_PU_Msk = 0x4000000
	// Bit PVTMON_PU.
	RTC_CNTL_ANA_CONF_PVTMON_PU = 0x4000000
	// Position of TXRF_I2C_PU field.
	RTC_CNTL_ANA_CONF_TXRF_I2C_PU_Pos = 0x1b
	// Bit mask of TXRF_I2C_PU field.
	RTC_CNTL_ANA_CONF_TXRF_I2C_PU_Msk = 0x8000000
	// Bit TXRF_I2C_PU.
	RTC_CNTL_ANA_CONF_TXRF_I2C_PU = 0x8000000
	// Position of RFRX_PBUS_PU field.
	RTC_CNTL_ANA_CONF_RFRX_PBUS_PU_Pos = 0x1c
	// Bit mask of RFRX_PBUS_PU field.
	RTC_CNTL_ANA_CONF_RFRX_PBUS_PU_Msk = 0x10000000
	// Bit RFRX_PBUS_PU.
	RTC_CNTL_ANA_CONF_RFRX_PBUS_PU = 0x10000000
	// Position of CKGEN_I2C_PU field.
	RTC_CNTL_ANA_CONF_CKGEN_I2C_PU_Pos = 0x1e
	// Bit mask of CKGEN_I2C_PU field.
	RTC_CNTL_ANA_CONF_CKGEN_I2C_PU_Msk = 0x40000000
	// Bit CKGEN_I2C_PU.
	RTC_CNTL_ANA_CONF_CKGEN_I2C_PU = 0x40000000
	// Position of PLL_I2C_PU field.
	RTC_CNTL_ANA_CONF_PLL_I2C_PU_Pos = 0x1f
	// Bit mask of PLL_I2C_PU field.
	RTC_CNTL_ANA_CONF_PLL_I2C_PU_Msk = 0x80000000
	// Bit PLL_I2C_PU.
	RTC_CNTL_ANA_CONF_PLL_I2C_PU = 0x80000000

	// RESET_STATE
	// Position of RESET_CAUSE_PROCPU field.
	RTC_CNTL_RESET_STATE_RESET_CAUSE_PROCPU_Pos = 0x0
	// Bit mask of RESET_CAUSE_PROCPU field.
	RTC_CNTL_RESET_STATE_RESET_CAUSE_PROCPU_Msk = 0x3f
	// Position of RESET_CAUSE_APPCPU field.
	RTC_CNTL_RESET_STATE_RESET_CAUSE_APPCPU_Pos = 0x6
	// Bit mask of RESET_CAUSE_APPCPU field.
	RTC_CNTL_RESET_STATE_RESET_CAUSE_APPCPU_Msk = 0xfc0
	// Position of APPCPU_STAT_VECTOR_SEL field.
	RTC_CNTL_RESET_STATE_APPCPU_STAT_VECTOR_SEL_Pos = 0xc
	// Bit mask of APPCPU_STAT_VECTOR_SEL field.
	RTC_CNTL_RESET_STATE_APPCPU_STAT_VECTOR_SEL_Msk = 0x1000
	// Bit APPCPU_STAT_VECTOR_SEL.
	RTC_CNTL_RESET_STATE_APPCPU_STAT_VECTOR_SEL = 0x1000
	// Position of PROCPU_STAT_VECTOR_SEL field.
	RTC_CNTL_RESET_STATE_PROCPU_STAT_VECTOR_SEL_Pos = 0xd
	// Bit mask of PROCPU_STAT_VECTOR_SEL field.
	RTC_CNTL_RESET_STATE_PROCPU_STAT_VECTOR_SEL_Msk = 0x2000
	// Bit PROCPU_STAT_VECTOR_SEL.
	RTC_CNTL_RESET_STATE_PROCPU_STAT_VECTOR_SEL = 0x2000

	// WAKEUP_STATE
	// Position of WAKEUP_CAUSE field.
	RTC_CNTL_WAKEUP_STATE_WAKEUP_CAUSE_Pos = 0x0
	// Bit mask of WAKEUP_CAUSE field.
	RTC_CNTL_WAKEUP_STATE_WAKEUP_CAUSE_Msk = 0x7ff
	// Position of WAKEUP_ENA field.
	RTC_CNTL_WAKEUP_STATE_WAKEUP_ENA_Pos = 0xb
	// Bit mask of WAKEUP_ENA field.
	RTC_CNTL_WAKEUP_STATE_WAKEUP_ENA_Msk = 0x3ff800
	// Position of GPIO_WAKEUP_FILTER field.
	RTC_CNTL_WAKEUP_STATE_GPIO_WAKEUP_FILTER_Pos = 0x16
	// Bit mask of GPIO_WAKEUP_FILTER field.
	RTC_CNTL_WAKEUP_STATE_GPIO_WAKEUP_FILTER_Msk = 0x400000
	// Bit GPIO_WAKEUP_FILTER.
	RTC_CNTL_WAKEUP_STATE_GPIO_WAKEUP_FILTER = 0x400000

	// INT_ENA
	// Position of SLP_WAKEUP_INT_ENA field.
	RTC_CNTL_INT_ENA_SLP_WAKEUP_INT_ENA_Pos = 0x0
	// Bit mask of SLP_WAKEUP_INT_ENA field.
	RTC_CNTL_INT_ENA_SLP_WAKEUP_INT_ENA_Msk = 0x1
	// Bit SLP_WAKEUP_INT_ENA.
	RTC_CNTL_INT_ENA_SLP_WAKEUP_INT_ENA = 0x1
	// Position of SLP_REJECT_INT_ENA field.
	RTC_CNTL_INT_ENA_SLP_REJECT_INT_ENA_Pos = 0x1
	// Bit mask of SLP_REJECT_INT_ENA field.
	RTC_CNTL_INT_ENA_SLP_REJECT_INT_ENA_Msk = 0x2
	// Bit SLP_REJECT_INT_ENA.
	RTC_CNTL_INT_ENA_SLP_REJECT_INT_ENA = 0x2
	// Position of SDIO_IDLE_INT_ENA field.
	RTC_CNTL_INT_ENA_SDIO_IDLE_INT_ENA_Pos = 0x2
	// Bit mask of SDIO_IDLE_INT_ENA field.
	RTC_CNTL_INT_ENA_SDIO_IDLE_INT_ENA_Msk = 0x4
	// Bit SDIO_IDLE_INT_ENA.
	RTC_CNTL_INT_ENA_SDIO_IDLE_INT_ENA = 0x4
	// Position of WDT_INT_ENA field.
	RTC_CNTL_INT_ENA_WDT_INT_ENA_Pos = 0x3
	// Bit mask of WDT_INT_ENA field.
	RTC_CNTL_INT_ENA_WDT_INT_ENA_Msk = 0x8
	// Bit WDT_INT_ENA.
	RTC_CNTL_INT_ENA_WDT_INT_ENA = 0x8
	// Position of TIME_VALID_INT_ENA field.
	RTC_CNTL_INT_ENA_TIME_VALID_INT_ENA_Pos = 0x4
	// Bit mask of TIME_VALID_INT_ENA field.
	RTC_CNTL_INT_ENA_TIME_VALID_INT_ENA_Msk = 0x10
	// Bit TIME_VALID_INT_ENA.
	RTC_CNTL_INT_ENA_TIME_VALID_INT_ENA = 0x10
	// Position of ULP_CP_INT_ENA field.
	RTC_CNTL_INT_ENA_ULP_CP_INT_ENA_Pos = 0x5
	// Bit mask of ULP_CP_INT_ENA field.
	RTC_CNTL_INT_ENA_ULP_CP_INT_ENA_Msk = 0x20
	// Bit ULP_CP_INT_ENA.
	RTC_CNTL_INT_ENA_ULP_CP_INT_ENA = 0x20
	// Position of TOUCH_INT_ENA field.
	RTC_CNTL_INT_ENA_TOUCH_INT_ENA_Pos = 0x6
	// Bit mask of TOUCH_INT_ENA field.
	RTC_CNTL_INT_ENA_TOUCH_INT_ENA_Msk = 0x40
	// Bit TOUCH_INT_ENA.
	RTC_CNTL_INT_ENA_TOUCH_INT_ENA = 0x40
	// Position of BROWN_OUT_INT_ENA field.
	RTC_CNTL_INT_ENA_BROWN_OUT_INT_ENA_Pos = 0x7
	// Bit mask of BROWN_OUT_INT_ENA field.
	RTC_CNTL_INT_ENA_BROWN_OUT_INT_ENA_Msk = 0x80
	// Bit BROWN_OUT_INT_ENA.
	RTC_CNTL_INT_ENA_BROWN_OUT_INT_ENA = 0x80
	// Position of MAIN_TIMER_INT_ENA field.
	RTC_CNTL_INT_ENA_MAIN_TIMER_INT_ENA_Pos = 0x8
	// Bit mask of MAIN_TIMER_INT_ENA field.
	RTC_CNTL_INT_ENA_MAIN_TIMER_INT_ENA_Msk = 0x100
	// Bit MAIN_TIMER_INT_ENA.
	RTC_CNTL_INT_ENA_MAIN_TIMER_INT_ENA = 0x100

	// INT_RAW
	// Position of SLP_WAKEUP_INT_RAW field.
	RTC_CNTL_INT_RAW_SLP_WAKEUP_INT_RAW_Pos = 0x0
	// Bit mask of SLP_WAKEUP_INT_RAW field.
	RTC_CNTL_INT_RAW_SLP_WAKEUP_INT_RAW_Msk = 0x1
	// Bit SLP_WAKEUP_INT_RAW.
	RTC_CNTL_INT_RAW_SLP_WAKEUP_INT_RAW = 0x1
	// Position of SLP_REJECT_INT_RAW field.
	RTC_CNTL_INT_RAW_SLP_REJECT_INT_RAW_Pos = 0x1
	// Bit mask of SLP_REJECT_INT_RAW field.
	RTC_CNTL_INT_RAW_SLP_REJECT_INT_RAW_Msk = 0x2
	// Bit SLP_REJECT_INT_RAW.
	RTC_CNTL_INT_RAW_SLP_REJECT_INT_RAW = 0x2
	// Position of SDIO_IDLE_INT_RAW field.
	RTC_CNTL_INT_RAW_SDIO_IDLE_INT_RAW_Pos = 0x2
	// Bit mask of SDIO_IDLE_INT_RAW field.
	RTC_CNTL_INT_RAW_SDIO_IDLE_INT_RAW_Msk = 0x4
	// Bit SDIO_IDLE_INT_RAW.
	RTC_CNTL_INT_RAW_SDIO_IDLE_INT_RAW = 0x4
	// Position of WDT_INT_RAW field.
	RTC_CNTL_INT_RAW_WDT_INT_RAW_Pos = 0x3
	// Bit mask of WDT_INT_RAW field.
	RTC_CNTL_INT_RAW_WDT_INT_RAW_Msk = 0x8
	// Bit WDT_INT_RAW.
	RTC_CNTL_INT_RAW_WDT_INT_RAW = 0x8
	// Position of TIME_VALID_INT_RAW field.
	RTC_CNTL_INT_RAW_TIME_VALID_INT_RAW_Pos = 0x4
	// Bit mask of TIME_VALID_INT_RAW field.
	RTC_CNTL_INT_RAW_TIME_VALID_INT_RAW_Msk = 0x10
	// Bit TIME_VALID_INT_RAW.
	RTC_CNTL_INT_RAW_TIME_VALID_INT_RAW = 0x10
	// Position of ULP_CP_INT_RAW field.
	RTC_CNTL_INT_RAW_ULP_CP_INT_RAW_Pos = 0x5
	// Bit mask of ULP_CP_INT_RAW field.
	RTC_CNTL_INT_RAW_ULP_CP_INT_RAW_Msk = 0x20
	// Bit ULP_CP_INT_RAW.
	RTC_CNTL_INT_RAW_ULP_CP_INT_RAW = 0x20
	// Position of TOUCH_INT_RAW field.
	RTC_CNTL_INT_RAW_TOUCH_INT_RAW_Pos = 0x6
	// Bit mask of TOUCH_INT_RAW field.
	RTC_CNTL_INT_RAW_TOUCH_INT_RAW_Msk = 0x40
	// Bit TOUCH_INT_RAW.
	RTC_CNTL_INT_RAW_TOUCH_INT_RAW = 0x40
	// Position of BROWN_OUT_INT_RAW field.
	RTC_CNTL_INT_RAW_BROWN_OUT_INT_RAW_Pos = 0x7
	// Bit mask of BROWN_OUT_INT_RAW field.
	RTC_CNTL_INT_RAW_BROWN_OUT_INT_RAW_Msk = 0x80
	// Bit BROWN_OUT_INT_RAW.
	RTC_CNTL_INT_RAW_BROWN_OUT_INT_RAW = 0x80
	// Position of MAIN_TIMER_INT_RAW field.
	RTC_CNTL_INT_RAW_MAIN_TIMER_INT_RAW_Pos = 0x8
	// Bit mask of MAIN_TIMER_INT_RAW field.
	RTC_CNTL_INT_RAW_MAIN_TIMER_INT_RAW_Msk = 0x100
	// Bit MAIN_TIMER_INT_RAW.
	RTC_CNTL_INT_RAW_MAIN_TIMER_INT_RAW = 0x100

	// INT_ST
	// Position of SLP_WAKEUP_INT_ST field.
	RTC_CNTL_INT_ST_SLP_WAKEUP_INT_ST_Pos = 0x0
	// Bit mask of SLP_WAKEUP_INT_ST field.
	RTC_CNTL_INT_ST_SLP_WAKEUP_INT_ST_Msk = 0x1
	// Bit SLP_WAKEUP_INT_ST.
	RTC_CNTL_INT_ST_SLP_WAKEUP_INT_ST = 0x1
	// Position of SLP_REJECT_INT_ST field.
	RTC_CNTL_INT_ST_SLP_REJECT_INT_ST_Pos = 0x1
	// Bit mask of SLP_REJECT_INT_ST field.
	RTC_CNTL_INT_ST_SLP_REJECT_INT_ST_Msk = 0x2
	// Bit SLP_REJECT_INT_ST.
	RTC_CNTL_INT_ST_SLP_REJECT_INT_ST = 0x2
	// Position of SDIO_IDLE_INT_ST field.
	RTC_CNTL_INT_ST_SDIO_IDLE_INT_ST_Pos = 0x2
	// Bit mask of SDIO_IDLE_INT_ST field.
	RTC_CNTL_INT_ST_SDIO_IDLE_INT_ST_Msk = 0x4
	// Bit SDIO_IDLE_INT_ST.
	RTC_CNTL_INT_ST_SDIO_IDLE_INT_ST = 0x4
	// Position of WDT_INT_ST field.
	RTC_CNTL_INT_ST_WDT_INT_ST_Pos = 0x3
	// Bit mask of WDT_INT_ST field.
	RTC_CNTL_INT_ST_WDT_INT_ST_Msk = 0x8
	// Bit WDT_INT_ST.
	RTC_CNTL_INT_ST_WDT_INT_ST = 0x8
	// Position of TIME_VALID_INT_ST field.
	RTC_CNTL_INT_ST_TIME_VALID_INT_ST_Pos = 0x4
	// Bit mask of TIME_VALID_INT_ST field.
	RTC_CNTL_INT_ST_TIME_VALID_INT_ST_Msk = 0x10
	// Bit TIME_VALID_INT_ST.
	RTC_CNTL_INT_ST_TIME_VALID_INT_ST = 0x10
	// Position of SAR_INT_ST field.
	RTC_CNTL_INT_ST_SAR_INT_ST_Pos = 0x5
	// Bit mask of SAR_INT_ST field.
	RTC_CNTL_INT_ST_SAR_INT_ST_Msk = 0x20
	// Bit SAR_INT_ST.
	RTC_CNTL_INT_ST_SAR_INT_ST = 0x20
	// Position of TOUCH_INT_ST field.
	RTC_CNTL_INT_ST_TOUCH_INT_ST_Pos = 0x6
	// Bit mask of TOUCH_INT_ST field.
	RTC_CNTL_INT_ST_TOUCH_INT_ST_Msk = 0x40
	// Bit TOUCH_INT_ST.
	RTC_CNTL_INT_ST_TOUCH_INT_ST = 0x40
	// Position of BROWN_OUT_INT_ST field.
	RTC_CNTL_INT_ST_BROWN_OUT_INT_ST_Pos = 0x7
	// Bit mask of BROWN_OUT_INT_ST field.
	RTC_CNTL_INT_ST_BROWN_OUT_INT_ST_Msk = 0x80
	// Bit BROWN_OUT_INT_ST.
	RTC_CNTL_INT_ST_BROWN_OUT_INT_ST = 0x80
	// Position of MAIN_TIMER_INT_ST field.
	RTC_CNTL_INT_ST_MAIN_TIMER_INT_ST_Pos = 0x8
	// Bit mask of MAIN_TIMER_INT_ST field.
	RTC_CNTL_INT_ST_MAIN_TIMER_INT_ST_Msk = 0x100
	// Bit MAIN_TIMER_INT_ST.
	RTC_CNTL_INT_ST_MAIN_TIMER_INT_ST = 0x100

	// INT_CLR
	// Position of SLP_WAKEUP_INT_CLR field.
	RTC_CNTL_INT_CLR_SLP_WAKEUP_INT_CLR_Pos = 0x0
	// Bit mask of SLP_WAKEUP_INT_CLR field.
	RTC_CNTL_INT_CLR_SLP_WAKEUP_INT_CLR_Msk = 0x1
	// Bit SLP_WAKEUP_INT_CLR.
	RTC_CNTL_INT_CLR_SLP_WAKEUP_INT_CLR = 0x1
	// Position of SLP_REJECT_INT_CLR field.
	RTC_CNTL_INT_CLR_SLP_REJECT_INT_CLR_Pos = 0x1
	// Bit mask of SLP_REJECT_INT_CLR field.
	RTC_CNTL_INT_CLR_SLP_REJECT_INT_CLR_Msk = 0x2
	// Bit SLP_REJECT_INT_CLR.
	RTC_CNTL_INT_CLR_SLP_REJECT_INT_CLR = 0x2
	// Position of SDIO_IDLE_INT_CLR field.
	RTC_CNTL_INT_CLR_SDIO_IDLE_INT_CLR_Pos = 0x2
	// Bit mask of SDIO_IDLE_INT_CLR field.
	RTC_CNTL_INT_CLR_SDIO_IDLE_INT_CLR_Msk = 0x4
	// Bit SDIO_IDLE_INT_CLR.
	RTC_CNTL_INT_CLR_SDIO_IDLE_INT_CLR = 0x4
	// Position of WDT_INT_CLR field.
	RTC_CNTL_INT_CLR_WDT_INT_CLR_Pos = 0x3
	// Bit mask of WDT_INT_CLR field.
	RTC_CNTL_INT_CLR_WDT_INT_CLR_Msk = 0x8
	// Bit WDT_INT_CLR.
	RTC_CNTL_INT_CLR_WDT_INT_CLR = 0x8
	// Position of TIME_VALID_INT_CLR field.
	RTC_CNTL_INT_CLR_TIME_VALID_INT_CLR_Pos = 0x4
	// Bit mask of TIME_VALID_INT_CLR field.
	RTC_CNTL_INT_CLR_TIME_VALID_INT_CLR_Msk = 0x10
	// Bit TIME_VALID_INT_CLR.
	RTC_CNTL_INT_CLR_TIME_VALID_INT_CLR = 0x10
	// Position of SAR_INT_CLR field.
	RTC_CNTL_INT_CLR_SAR_INT_CLR_Pos = 0x5
	// Bit mask of SAR_INT_CLR field.
	RTC_CNTL_INT_CLR_SAR_INT_CLR_Msk = 0x20
	// Bit SAR_INT_CLR.
	RTC_CNTL_INT_CLR_SAR_INT_CLR = 0x20
	// Position of TOUCH_INT_CLR field.
	RTC_CNTL_INT_CLR_TOUCH_INT_CLR_Pos = 0x6
	// Bit mask of TOUCH_INT_CLR field.
	RTC_CNTL_INT_CLR_TOUCH_INT_CLR_Msk = 0x40
	// Bit TOUCH_INT_CLR.
	RTC_CNTL_INT_CLR_TOUCH_INT_CLR = 0x40
	// Position of BROWN_OUT_INT_CLR field.
	RTC_CNTL_INT_CLR_BROWN_OUT_INT_CLR_Pos = 0x7
	// Bit mask of BROWN_OUT_INT_CLR field.
	RTC_CNTL_INT_CLR_BROWN_OUT_INT_CLR_Msk = 0x80
	// Bit BROWN_OUT_INT_CLR.
	RTC_CNTL_INT_CLR_BROWN_OUT_INT_CLR = 0x80
	// Position of MAIN_TIMER_INT_CLR field.
	RTC_CNTL_INT_CLR_MAIN_TIMER_INT_CLR_Pos = 0x8
	// Bit mask of MAIN_TIMER_INT_CLR field.
	RTC_CNTL_INT_CLR_MAIN_TIMER_INT_CLR_Msk = 0x100
	// Bit MAIN_TIMER_INT_CLR.
	RTC_CNTL_INT_CLR_MAIN_TIMER_INT_CLR = 0x100

	// STORE0
	// Position of SCRATCH0 field.
	RTC_CNTL_STORE0_SCRATCH0_Pos = 0x0
	// Bit mask of SCRATCH0 field.
	RTC_CNTL_STORE0_SCRATCH0_Msk = 0xffffffff

	// STORE1
	// Position of SCRATCH1 field.
	RTC_CNTL_STORE1_SCRATCH1_Pos = 0x0
	// Bit mask of SCRATCH1 field.
	RTC_CNTL_STORE1_SCRATCH1_Msk = 0xffffffff

	// STORE2
	// Position of SCRATCH2 field.
	RTC_CNTL_STORE2_SCRATCH2_Pos = 0x0
	// Bit mask of SCRATCH2 field.
	RTC_CNTL_STORE2_SCRATCH2_Msk = 0xffffffff

	// STORE3
	// Position of SCRATCH3 field.
	RTC_CNTL_STORE3_SCRATCH3_Pos = 0x0
	// Bit mask of SCRATCH3 field.
	RTC_CNTL_STORE3_SCRATCH3_Msk = 0xffffffff

	// EXT_XTL_CONF
	// Position of XTL_EXT_CTR_LV field.
	RTC_CNTL_EXT_XTL_CONF_XTL_EXT_CTR_LV_Pos = 0x1e
	// Bit mask of XTL_EXT_CTR_LV field.
	RTC_CNTL_EXT_XTL_CONF_XTL_EXT_CTR_LV_Msk = 0x40000000
	// Bit XTL_EXT_CTR_LV.
	RTC_CNTL_EXT_XTL_CONF_XTL_EXT_CTR_LV = 0x40000000
	// Position of XTL_EXT_CTR_EN field.
	RTC_CNTL_EXT_XTL_CONF_XTL_EXT_CTR_EN_Pos = 0x1f
	// Bit mask of XTL_EXT_CTR_EN field.
	RTC_CNTL_EXT_XTL_CONF_XTL_EXT_CTR_EN_Msk = 0x80000000
	// Bit XTL_EXT_CTR_EN.
	RTC_CNTL_EXT_XTL_CONF_XTL_EXT_CTR_EN = 0x80000000

	// EXT_WAKEUP_CONF
	// Position of EXT_WAKEUP0_LV field.
	RTC_CNTL_EXT_WAKEUP_CONF_EXT_WAKEUP0_LV_Pos = 0x1e
	// Bit mask of EXT_WAKEUP0_LV field.
	RTC_CNTL_EXT_WAKEUP_CONF_EXT_WAKEUP0_LV_Msk = 0x40000000
	// Bit EXT_WAKEUP0_LV.
	RTC_CNTL_EXT_WAKEUP_CONF_EXT_WAKEUP0_LV = 0x40000000
	// Position of EXT_WAKEUP1_LV field.
	RTC_CNTL_EXT_WAKEUP_CONF_EXT_WAKEUP1_LV_Pos = 0x1f
	// Bit mask of EXT_WAKEUP1_LV field.
	RTC_CNTL_EXT_WAKEUP_CONF_EXT_WAKEUP1_LV_Msk = 0x80000000
	// Bit EXT_WAKEUP1_LV.
	RTC_CNTL_EXT_WAKEUP_CONF_EXT_WAKEUP1_LV = 0x80000000

	// SLP_REJECT_CONF
	// Position of GPIO_REJECT_EN field.
	RTC_CNTL_SLP_REJECT_CONF_GPIO_REJECT_EN_Pos = 0x18
	// Bit mask of GPIO_REJECT_EN field.
	RTC_CNTL_SLP_REJECT_CONF_GPIO_REJECT_EN_Msk = 0x1000000
	// Bit GPIO_REJECT_EN.
	RTC_CNTL_SLP_REJECT_CONF_GPIO_REJECT_EN = 0x1000000
	// Position of SDIO_REJECT_EN field.
	RTC_CNTL_SLP_REJECT_CONF_SDIO_REJECT_EN_Pos = 0x19
	// Bit mask of SDIO_REJECT_EN field.
	RTC_CNTL_SLP_REJECT_CONF_SDIO_REJECT_EN_Msk = 0x2000000
	// Bit SDIO_REJECT_EN.
	RTC_CNTL_SLP_REJECT_CONF_SDIO_REJECT_EN = 0x2000000
	// Position of LIGHT_SLP_REJECT_EN field.
	RTC_CNTL_SLP_REJECT_CONF_LIGHT_SLP_REJECT_EN_Pos = 0x1a
	// Bit mask of LIGHT_SLP_REJECT_EN field.
	RTC_CNTL_SLP_REJECT_CONF_LIGHT_SLP_REJECT_EN_Msk = 0x4000000
	// Bit LIGHT_SLP_REJECT_EN.
	RTC_CNTL_SLP_REJECT_CONF_LIGHT_SLP_REJECT_EN = 0x4000000
	// Position of DEEP_SLP_REJECT_EN field.
	RTC_CNTL_SLP_REJECT_CONF_DEEP_SLP_REJECT_EN_Pos = 0x1b
	// Bit mask of DEEP_SLP_REJECT_EN field.
	RTC_CNTL_SLP_REJECT_CONF_DEEP_SLP_REJECT_EN_Msk = 0x8000000
	// Bit DEEP_SLP_REJECT_EN.
	RTC_CNTL_SLP_REJECT_CONF_DEEP_SLP_REJECT_EN = 0x8000000
	// Position of REJECT_CAUSE field.
	RTC_CNTL_SLP_REJECT_CONF_REJECT_CAUSE_Pos = 0x1c
	// Bit mask of REJECT_CAUSE field.
	RTC_CNTL_SLP_REJECT_CONF_REJECT_CAUSE_Msk = 0xf0000000

	// CPU_PERIOD_CONF
	// Position of CPUSEL_CONF field.
	RTC_CNTL_CPU_PERIOD_CONF_CPUSEL_CONF_Pos = 0x1d
	// Bit mask of CPUSEL_CONF field.
	RTC_CNTL_CPU_PERIOD_CONF_CPUSEL_CONF_Msk = 0x20000000
	// Bit CPUSEL_CONF.
	RTC_CNTL_CPU_PERIOD_CONF_CPUSEL_CONF = 0x20000000
	// Position of CPUPERIOD_SEL field.
	RTC_CNTL_CPU_PERIOD_CONF_CPUPERIOD_SEL_Pos = 0x1e
	// Bit mask of CPUPERIOD_SEL field.
	RTC_CNTL_CPU_PERIOD_CONF_CPUPERIOD_SEL_Msk = 0xc0000000

	// SDIO_ACT_CONF
	// Position of SDIO_ACT_DNUM field.
	RTC_CNTL_SDIO_ACT_CONF_SDIO_ACT_DNUM_Pos = 0x16
	// Bit mask of SDIO_ACT_DNUM field.
	RTC_CNTL_SDIO_ACT_CONF_SDIO_ACT_DNUM_Msk = 0xffc00000

	// CLK_CONF
	// Position of CK8M_DIV field.
	RTC_CNTL_CLK_CONF_CK8M_DIV_Pos = 0x4
	// Bit mask of CK8M_DIV field.
	RTC_CNTL_CLK_CONF_CK8M_DIV_Msk = 0x30
	// DIV128
	RTC_CNTL_CLK_CONF_CK8M_DIV_DIV128 = 0x0
	// DIV256
	RTC_CNTL_CLK_CONF_CK8M_DIV_DIV256 = 0x1
	// DIV512
	RTC_CNTL_CLK_CONF_CK8M_DIV_DIV512 = 0x2
	// DIV1024
	RTC_CNTL_CLK_CONF_CK8M_DIV_DIV1024 = 0x3
	// Position of ENB_CK8M field.
	RTC_CNTL_CLK_CONF_ENB_CK8M_Pos = 0x6
	// Bit mask of ENB_CK8M field.
	RTC_CNTL_CLK_CONF_ENB_CK8M_Msk = 0x40
	// Bit ENB_CK8M.
	RTC_CNTL_CLK_CONF_ENB_CK8M = 0x40
	// Position of ENB_CK8M_DIV field.
	RTC_CNTL_CLK_CONF_ENB_CK8M_DIV_Pos = 0x7
	// Bit mask of ENB_CK8M_DIV field.
	RTC_CNTL_CLK_CONF_ENB_CK8M_DIV_Msk = 0x80
	// Bit ENB_CK8M_DIV.
	RTC_CNTL_CLK_CONF_ENB_CK8M_DIV = 0x80
	// CK8M_DIV_256
	RTC_CNTL_CLK_CONF_ENB_CK8M_DIV_CK8M_DIV_256 = 0x0
	// CK8M
	RTC_CNTL_CLK_CONF_ENB_CK8M_DIV_CK8M = 0x1
	// Position of DIG_XTAL32K_EN field.
	RTC_CNTL_CLK_CONF_DIG_XTAL32K_EN_Pos = 0x8
	// Bit mask of DIG_XTAL32K_EN field.
	RTC_CNTL_CLK_CONF_DIG_XTAL32K_EN_Msk = 0x100
	// Bit DIG_XTAL32K_EN.
	RTC_CNTL_CLK_CONF_DIG_XTAL32K_EN = 0x100
	// Position of DIG_CLK8M_D256_EN field.
	RTC_CNTL_CLK_CONF_DIG_CLK8M_D256_EN_Pos = 0x9
	// Bit mask of DIG_CLK8M_D256_EN field.
	RTC_CNTL_CLK_CONF_DIG_CLK8M_D256_EN_Msk = 0x200
	// Bit DIG_CLK8M_D256_EN.
	RTC_CNTL_CLK_CONF_DIG_CLK8M_D256_EN = 0x200
	// Position of DIG_CLK8M_EN field.
	RTC_CNTL_CLK_CONF_DIG_CLK8M_EN_Pos = 0xa
	// Bit mask of DIG_CLK8M_EN field.
	RTC_CNTL_CLK_CONF_DIG_CLK8M_EN_Msk = 0x400
	// Bit DIG_CLK8M_EN.
	RTC_CNTL_CLK_CONF_DIG_CLK8M_EN = 0x400
	// Position of CK8M_DFREQ_FORCE field.
	RTC_CNTL_CLK_CONF_CK8M_DFREQ_FORCE_Pos = 0xb
	// Bit mask of CK8M_DFREQ_FORCE field.
	RTC_CNTL_CLK_CONF_CK8M_DFREQ_FORCE_Msk = 0x800
	// Bit CK8M_DFREQ_FORCE.
	RTC_CNTL_CLK_CONF_CK8M_DFREQ_FORCE = 0x800
	// Position of CK8M_DIV_SEL field.
	RTC_CNTL_CLK_CONF_CK8M_DIV_SEL_Pos = 0xc
	// Bit mask of CK8M_DIV_SEL field.
	RTC_CNTL_CLK_CONF_CK8M_DIV_SEL_Msk = 0x7000
	// Position of XTAL_FORCE_NOGATING field.
	RTC_CNTL_CLK_CONF_XTAL_FORCE_NOGATING_Pos = 0xf
	// Bit mask of XTAL_FORCE_NOGATING field.
	RTC_CNTL_CLK_CONF_XTAL_FORCE_NOGATING_Msk = 0x8000
	// Bit XTAL_FORCE_NOGATING.
	RTC_CNTL_CLK_CONF_XTAL_FORCE_NOGATING = 0x8000
	// Position of CK8M_FORCE_NOGATING field.
	RTC_CNTL_CLK_CONF_CK8M_FORCE_NOGATING_Pos = 0x10
	// Bit mask of CK8M_FORCE_NOGATING field.
	RTC_CNTL_CLK_CONF_CK8M_FORCE_NOGATING_Msk = 0x10000
	// Bit CK8M_FORCE_NOGATING.
	RTC_CNTL_CLK_CONF_CK8M_FORCE_NOGATING = 0x10000
	// Position of CK8M_DFREQ field.
	RTC_CNTL_CLK_CONF_CK8M_DFREQ_Pos = 0x11
	// Bit mask of CK8M_DFREQ field.
	RTC_CNTL_CLK_CONF_CK8M_DFREQ_Msk = 0x1fe0000
	// Position of CK8M_FORCE_PD field.
	RTC_CNTL_CLK_CONF_CK8M_FORCE_PD_Pos = 0x19
	// Bit mask of CK8M_FORCE_PD field.
	RTC_CNTL_CLK_CONF_CK8M_FORCE_PD_Msk = 0x2000000
	// Bit CK8M_FORCE_PD.
	RTC_CNTL_CLK_CONF_CK8M_FORCE_PD = 0x2000000
	// Position of CK8M_FORCE_PU field.
	RTC_CNTL_CLK_CONF_CK8M_FORCE_PU_Pos = 0x1a
	// Bit mask of CK8M_FORCE_PU field.
	RTC_CNTL_CLK_CONF_CK8M_FORCE_PU_Msk = 0x4000000
	// Bit CK8M_FORCE_PU.
	RTC_CNTL_CLK_CONF_CK8M_FORCE_PU = 0x4000000
	// Position of SOC_CLK_SEL field.
	RTC_CNTL_CLK_CONF_SOC_CLK_SEL_Pos = 0x1b
	// Bit mask of SOC_CLK_SEL field.
	RTC_CNTL_CLK_CONF_SOC_CLK_SEL_Msk = 0x18000000
	// XTAL
	RTC_CNTL_CLK_CONF_SOC_CLK_SEL_XTAL = 0x0
	// PLL
	RTC_CNTL_CLK_CONF_SOC_CLK_SEL_PLL = 0x1
	// CK8M
	RTC_CNTL_CLK_CONF_SOC_CLK_SEL_CK8M = 0x2
	// APLL
	RTC_CNTL_CLK_CONF_SOC_CLK_SEL_APLL = 0x3
	// Position of FAST_CLK_RTC_SEL field.
	RTC_CNTL_CLK_CONF_FAST_CLK_RTC_SEL_Pos = 0x1d
	// Bit mask of FAST_CLK_RTC_SEL field.
	RTC_CNTL_CLK_CONF_FAST_CLK_RTC_SEL_Msk = 0x20000000
	// Bit FAST_CLK_RTC_SEL.
	RTC_CNTL_CLK_CONF_FAST_CLK_RTC_SEL = 0x20000000
	// XTAL_DIV_4
	RTC_CNTL_CLK_CONF_FAST_CLK_RTC_SEL_XTAL_DIV_4 = 0x0
	// CK8M
	RTC_CNTL_CLK_CONF_FAST_CLK_RTC_SEL_CK8M = 0x1
	// Position of ANA_CLK_RTC_SEL field.
	RTC_CNTL_CLK_CONF_ANA_CLK_RTC_SEL_Pos = 0x1e
	// Bit mask of ANA_CLK_RTC_SEL field.
	RTC_CNTL_CLK_CONF_ANA_CLK_RTC_SEL_Msk = 0xc0000000
	// SLOW_CK
	RTC_CNTL_CLK_CONF_ANA_CLK_RTC_SEL_SLOW_CK = 0x0
	// CK_XTAL_32K
	RTC_CNTL_CLK_CONF_ANA_CLK_RTC_SEL_CK_XTAL_32K = 0x1
	// CK8M_D256_OUT
	RTC_CNTL_CLK_CONF_ANA_CLK_RTC_SEL_CK8M_D256_OUT = 0x2

	// SDIO_CONF
	// Position of SDIO_PD_EN field.
	RTC_CNTL_SDIO_CONF_SDIO_PD_EN_Pos = 0x15
	// Bit mask of SDIO_PD_EN field.
	RTC_CNTL_SDIO_CONF_SDIO_PD_EN_Msk = 0x200000
	// Bit SDIO_PD_EN.
	RTC_CNTL_SDIO_CONF_SDIO_PD_EN = 0x200000
	// Position of SDIO_FORCE field.
	RTC_CNTL_SDIO_CONF_SDIO_FORCE_Pos = 0x16
	// Bit mask of SDIO_FORCE field.
	RTC_CNTL_SDIO_CONF_SDIO_FORCE_Msk = 0x400000
	// Bit SDIO_FORCE.
	RTC_CNTL_SDIO_CONF_SDIO_FORCE = 0x400000
	// Position of SDIO_TIEH field.
	RTC_CNTL_SDIO_CONF_SDIO_TIEH_Pos = 0x17
	// Bit mask of SDIO_TIEH field.
	RTC_CNTL_SDIO_CONF_SDIO_TIEH_Msk = 0x800000
	// Bit SDIO_TIEH.
	RTC_CNTL_SDIO_CONF_SDIO_TIEH = 0x800000
	// Position of REG1P8_READY field.
	RTC_CNTL_SDIO_CONF_REG1P8_READY_Pos = 0x18
	// Bit mask of REG1P8_READY field.
	RTC_CNTL_SDIO_CONF_REG1P8_READY_Msk = 0x1000000
	// Bit REG1P8_READY.
	RTC_CNTL_SDIO_CONF_REG1P8_READY = 0x1000000
	// Position of DREFL_SDIO field.
	RTC_CNTL_SDIO_CONF_DREFL_SDIO_Pos = 0x19
	// Bit mask of DREFL_SDIO field.
	RTC_CNTL_SDIO_CONF_DREFL_SDIO_Msk = 0x6000000
	// Position of DREFM_SDIO field.
	RTC_CNTL_SDIO_CONF_DREFM_SDIO_Pos = 0x1b
	// Bit mask of DREFM_SDIO field.
	RTC_CNTL_SDIO_CONF_DREFM_SDIO_Msk = 0x18000000
	// Position of DREFH_SDIO field.
	RTC_CNTL_SDIO_CONF_DREFH_SDIO_Pos = 0x1d
	// Bit mask of DREFH_SDIO field.
	RTC_CNTL_SDIO_CONF_DREFH_SDIO_Msk = 0x60000000
	// Position of XPD_SDIO field.
	RTC_CNTL_SDIO_CONF_XPD_SDIO_Pos = 0x1f
	// Bit mask of XPD_SDIO field.
	RTC_CNTL_SDIO_CONF_XPD_SDIO_Msk = 0x80000000
	// Bit XPD_SDIO.
	RTC_CNTL_SDIO_CONF_XPD_SDIO = 0x80000000

	// BIAS_CONF
	// Position of DBG_ATTEN field.
	RTC_CNTL_BIAS_CONF_DBG_ATTEN_Pos = 0x18
	// Bit mask of DBG_ATTEN field.
	RTC_CNTL_BIAS_CONF_DBG_ATTEN_Msk = 0x3000000
	// Position of ENB_SCK_XTAL field.
	RTC_CNTL_BIAS_CONF_ENB_SCK_XTAL_Pos = 0x1a
	// Bit mask of ENB_SCK_XTAL field.
	RTC_CNTL_BIAS_CONF_ENB_SCK_XTAL_Msk = 0x4000000
	// Bit ENB_SCK_XTAL.
	RTC_CNTL_BIAS_CONF_ENB_SCK_XTAL = 0x4000000
	// Position of INC_HEARTBEAT_REFRESH field.
	RTC_CNTL_BIAS_CONF_INC_HEARTBEAT_REFRESH_Pos = 0x1b
	// Bit mask of INC_HEARTBEAT_REFRESH field.
	RTC_CNTL_BIAS_CONF_INC_HEARTBEAT_REFRESH_Msk = 0x8000000
	// Bit INC_HEARTBEAT_REFRESH.
	RTC_CNTL_BIAS_CONF_INC_HEARTBEAT_REFRESH = 0x8000000
	// Position of DEC_HEARTBEAT_PERIOD field.
	RTC_CNTL_BIAS_CONF_DEC_HEARTBEAT_PERIOD_Pos = 0x1c
	// Bit mask of DEC_HEARTBEAT_PERIOD field.
	RTC_CNTL_BIAS_CONF_DEC_HEARTBEAT_PERIOD_Msk = 0x10000000
	// Bit DEC_HEARTBEAT_PERIOD.
	RTC_CNTL_BIAS_CONF_DEC_HEARTBEAT_PERIOD = 0x10000000
	// Position of INC_HEARTBEAT_PERIOD field.
	RTC_CNTL_BIAS_CONF_INC_HEARTBEAT_PERIOD_Pos = 0x1d
	// Bit mask of INC_HEARTBEAT_PERIOD field.
	RTC_CNTL_BIAS_CONF_INC_HEARTBEAT_PERIOD_Msk = 0x20000000
	// Bit INC_HEARTBEAT_PERIOD.
	RTC_CNTL_BIAS_CONF_INC_HEARTBEAT_PERIOD = 0x20000000
	// Position of DEC_HEARTBEAT_WIDTH field.
	RTC_CNTL_BIAS_CONF_DEC_HEARTBEAT_WIDTH_Pos = 0x1e
	// Bit mask of DEC_HEARTBEAT_WIDTH field.
	RTC_CNTL_BIAS_CONF_DEC_HEARTBEAT_WIDTH_Msk = 0x40000000
	// Bit DEC_HEARTBEAT_WIDTH.
	RTC_CNTL_BIAS_CONF_DEC_HEARTBEAT_WIDTH = 0x40000000
	// Position of RST_BIAS_I2C field.
	RTC_CNTL_BIAS_CONF_RST_BIAS_I2C_Pos = 0x1f
	// Bit mask of RST_BIAS_I2C field.
	RTC_CNTL_BIAS_CONF_RST_BIAS_I2C_Msk = 0x80000000
	// Bit RST_BIAS_I2C.
	RTC_CNTL_BIAS_CONF_RST_BIAS_I2C = 0x80000000

	// REG
	// Position of SCK_DCAP_FORCE field.
	RTC_CNTL_REG_SCK_DCAP_FORCE_Pos = 0x7
	// Bit mask of SCK_DCAP_FORCE field.
	RTC_CNTL_REG_SCK_DCAP_FORCE_Msk = 0x80
	// Bit SCK_DCAP_FORCE.
	RTC_CNTL_REG_SCK_DCAP_FORCE = 0x80
	// Position of DIG_DBIAS_SLP field.
	RTC_CNTL_REG_DIG_DBIAS_SLP_Pos = 0x8
	// Bit mask of DIG_DBIAS_SLP field.
	RTC_CNTL_REG_DIG_DBIAS_SLP_Msk = 0x700
	// Position of DIG_DBIAS_WAK field.
	RTC_CNTL_REG_DIG_DBIAS_WAK_Pos = 0xb
	// Bit mask of DIG_DBIAS_WAK field.
	RTC_CNTL_REG_DIG_DBIAS_WAK_Msk = 0x3800
	// Position of SCK_DCAP field.
	RTC_CNTL_REG_SCK_DCAP_Pos = 0xe
	// Bit mask of SCK_DCAP field.
	RTC_CNTL_REG_SCK_DCAP_Msk = 0x3fc000
	// Position of DBIAS_SLP field.
	RTC_CNTL_REG_DBIAS_SLP_Pos = 0x16
	// Bit mask of DBIAS_SLP field.
	RTC_CNTL_REG_DBIAS_SLP_Msk = 0x1c00000
	// Position of DBIAS_WAK field.
	RTC_CNTL_REG_DBIAS_WAK_Pos = 0x19
	// Bit mask of DBIAS_WAK field.
	RTC_CNTL_REG_DBIAS_WAK_Msk = 0xe000000
	// Position of DBOOST_FORCE_PD field.
	RTC_CNTL_REG_DBOOST_FORCE_PD_Pos = 0x1c
	// Bit mask of DBOOST_FORCE_PD field.
	RTC_CNTL_REG_DBOOST_FORCE_PD_Msk = 0x10000000
	// Bit DBOOST_FORCE_PD.
	RTC_CNTL_REG_DBOOST_FORCE_PD = 0x10000000
	// Position of DBOOST_FORCE_PU field.
	RTC_CNTL_REG_DBOOST_FORCE_PU_Pos = 0x1d
	// Bit mask of DBOOST_FORCE_PU field.
	RTC_CNTL_REG_DBOOST_FORCE_PU_Msk = 0x20000000
	// Bit DBOOST_FORCE_PU.
	RTC_CNTL_REG_DBOOST_FORCE_PU = 0x20000000
	// Position of FORCE_PD field.
	RTC_CNTL_REG_FORCE_PD_Pos = 0x1e
	// Bit mask of FORCE_PD field.
	RTC_CNTL_REG_FORCE_PD_Msk = 0x40000000
	// Bit FORCE_PD.
	RTC_CNTL_REG_FORCE_PD = 0x40000000
	// Position of FORCE_PU field.
	RTC_CNTL_REG_FORCE_PU_Pos = 0x1f
	// Bit mask of FORCE_PU field.
	RTC_CNTL_REG_FORCE_PU_Msk = 0x80000000
	// Bit FORCE_PU.
	RTC_CNTL_REG_FORCE_PU = 0x80000000

	// PWC
	// Position of FASTMEM_FORCE_NOISO field.
	RTC_CNTL_PWC_FASTMEM_FORCE_NOISO_Pos = 0x0
	// Bit mask of FASTMEM_FORCE_NOISO field.
	RTC_CNTL_PWC_FASTMEM_FORCE_NOISO_Msk = 0x1
	// Bit FASTMEM_FORCE_NOISO.
	RTC_CNTL_PWC_FASTMEM_FORCE_NOISO = 0x1
	// Position of FASTMEM_FORCE_ISO field.
	RTC_CNTL_PWC_FASTMEM_FORCE_ISO_Pos = 0x1
	// Bit mask of FASTMEM_FORCE_ISO field.
	RTC_CNTL_PWC_FASTMEM_FORCE_ISO_Msk = 0x2
	// Bit FASTMEM_FORCE_ISO.
	RTC_CNTL_PWC_FASTMEM_FORCE_ISO = 0x2
	// Position of SLOWMEM_FORCE_NOISO field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_NOISO_Pos = 0x2
	// Bit mask of SLOWMEM_FORCE_NOISO field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_NOISO_Msk = 0x4
	// Bit SLOWMEM_FORCE_NOISO.
	RTC_CNTL_PWC_SLOWMEM_FORCE_NOISO = 0x4
	// Position of SLOWMEM_FORCE_ISO field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_ISO_Pos = 0x3
	// Bit mask of SLOWMEM_FORCE_ISO field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_ISO_Msk = 0x8
	// Bit SLOWMEM_FORCE_ISO.
	RTC_CNTL_PWC_SLOWMEM_FORCE_ISO = 0x8
	// Position of FORCE_ISO field.
	RTC_CNTL_PWC_FORCE_ISO_Pos = 0x4
	// Bit mask of FORCE_ISO field.
	RTC_CNTL_PWC_FORCE_ISO_Msk = 0x10
	// Bit FORCE_ISO.
	RTC_CNTL_PWC_FORCE_ISO = 0x10
	// Position of FORCE_NOISO field.
	RTC_CNTL_PWC_FORCE_NOISO_Pos = 0x5
	// Bit mask of FORCE_NOISO field.
	RTC_CNTL_PWC_FORCE_NOISO_Msk = 0x20
	// Bit FORCE_NOISO.
	RTC_CNTL_PWC_FORCE_NOISO = 0x20
	// Position of FASTMEM_FOLW_CPU field.
	RTC_CNTL_PWC_FASTMEM_FOLW_CPU_Pos = 0x6
	// Bit mask of FASTMEM_FOLW_CPU field.
	RTC_CNTL_PWC_FASTMEM_FOLW_CPU_Msk = 0x40
	// Bit FASTMEM_FOLW_CPU.
	RTC_CNTL_PWC_FASTMEM_FOLW_CPU = 0x40
	// Position of FASTMEM_FORCE_LPD field.
	RTC_CNTL_PWC_FASTMEM_FORCE_LPD_Pos = 0x7
	// Bit mask of FASTMEM_FORCE_LPD field.
	RTC_CNTL_PWC_FASTMEM_FORCE_LPD_Msk = 0x80
	// Bit FASTMEM_FORCE_LPD.
	RTC_CNTL_PWC_FASTMEM_FORCE_LPD = 0x80
	// Position of FASTMEM_FORCE_LPU field.
	RTC_CNTL_PWC_FASTMEM_FORCE_LPU_Pos = 0x8
	// Bit mask of FASTMEM_FORCE_LPU field.
	RTC_CNTL_PWC_FASTMEM_FORCE_LPU_Msk = 0x100
	// Bit FASTMEM_FORCE_LPU.
	RTC_CNTL_PWC_FASTMEM_FORCE_LPU = 0x100
	// Position of SLOWMEM_FOLW_CPU field.
	RTC_CNTL_PWC_SLOWMEM_FOLW_CPU_Pos = 0x9
	// Bit mask of SLOWMEM_FOLW_CPU field.
	RTC_CNTL_PWC_SLOWMEM_FOLW_CPU_Msk = 0x200
	// Bit SLOWMEM_FOLW_CPU.
	RTC_CNTL_PWC_SLOWMEM_FOLW_CPU = 0x200
	// Position of SLOWMEM_FORCE_LPD field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_LPD_Pos = 0xa
	// Bit mask of SLOWMEM_FORCE_LPD field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_LPD_Msk = 0x400
	// Bit SLOWMEM_FORCE_LPD.
	RTC_CNTL_PWC_SLOWMEM_FORCE_LPD = 0x400
	// Position of SLOWMEM_FORCE_LPU field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_LPU_Pos = 0xb
	// Bit mask of SLOWMEM_FORCE_LPU field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_LPU_Msk = 0x800
	// Bit SLOWMEM_FORCE_LPU.
	RTC_CNTL_PWC_SLOWMEM_FORCE_LPU = 0x800
	// Position of FASTMEM_FORCE_PD field.
	RTC_CNTL_PWC_FASTMEM_FORCE_PD_Pos = 0xc
	// Bit mask of FASTMEM_FORCE_PD field.
	RTC_CNTL_PWC_FASTMEM_FORCE_PD_Msk = 0x1000
	// Bit FASTMEM_FORCE_PD.
	RTC_CNTL_PWC_FASTMEM_FORCE_PD = 0x1000
	// Position of FASTMEM_FORCE_PU field.
	RTC_CNTL_PWC_FASTMEM_FORCE_PU_Pos = 0xd
	// Bit mask of FASTMEM_FORCE_PU field.
	RTC_CNTL_PWC_FASTMEM_FORCE_PU_Msk = 0x2000
	// Bit FASTMEM_FORCE_PU.
	RTC_CNTL_PWC_FASTMEM_FORCE_PU = 0x2000
	// Position of FASTMEM_PD_EN field.
	RTC_CNTL_PWC_FASTMEM_PD_EN_Pos = 0xe
	// Bit mask of FASTMEM_PD_EN field.
	RTC_CNTL_PWC_FASTMEM_PD_EN_Msk = 0x4000
	// Bit FASTMEM_PD_EN.
	RTC_CNTL_PWC_FASTMEM_PD_EN = 0x4000
	// Position of SLOWMEM_FORCE_PD field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_PD_Pos = 0xf
	// Bit mask of SLOWMEM_FORCE_PD field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_PD_Msk = 0x8000
	// Bit SLOWMEM_FORCE_PD.
	RTC_CNTL_PWC_SLOWMEM_FORCE_PD = 0x8000
	// Position of SLOWMEM_FORCE_PU field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_PU_Pos = 0x10
	// Bit mask of SLOWMEM_FORCE_PU field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_PU_Msk = 0x10000
	// Bit SLOWMEM_FORCE_PU.
	RTC_CNTL_PWC_SLOWMEM_FORCE_PU = 0x10000
	// Position of SLOWMEM_PD_EN field.
	RTC_CNTL_PWC_SLOWMEM_PD_EN_Pos = 0x11
	// Bit mask of SLOWMEM_PD_EN field.
	RTC_CNTL_PWC_SLOWMEM_PD_EN_Msk = 0x20000
	// Bit SLOWMEM_PD_EN.
	RTC_CNTL_PWC_SLOWMEM_PD_EN = 0x20000
	// Position of FORCE_PD field.
	RTC_CNTL_PWC_FORCE_PD_Pos = 0x12
	// Bit mask of FORCE_PD field.
	RTC_CNTL_PWC_FORCE_PD_Msk = 0x40000
	// Bit FORCE_PD.
	RTC_CNTL_PWC_FORCE_PD = 0x40000
	// Position of FORCE_PU field.
	RTC_CNTL_PWC_FORCE_PU_Pos = 0x13
	// Bit mask of FORCE_PU field.
	RTC_CNTL_PWC_FORCE_PU_Msk = 0x80000
	// Bit FORCE_PU.
	RTC_CNTL_PWC_FORCE_PU = 0x80000
	// Position of PD_EN field.
	RTC_CNTL_PWC_PD_EN_Pos = 0x14
	// Bit mask of PD_EN field.
	RTC_CNTL_PWC_PD_EN_Msk = 0x100000
	// Bit PD_EN.
	RTC_CNTL_PWC_PD_EN = 0x100000

	// DIG_PWC
	// Position of LSLP_MEM_FORCE_PD field.
	RTC_CNTL_DIG_PWC_LSLP_MEM_FORCE_PD_Pos = 0x3
	// Bit mask of LSLP_MEM_FORCE_PD field.
	RTC_CNTL_DIG_PWC_LSLP_MEM_FORCE_PD_Msk = 0x8
	// Bit LSLP_MEM_FORCE_PD.
	RTC_CNTL_DIG_PWC_LSLP_MEM_FORCE_PD = 0x8
	// Position of LSLP_MEM_FORCE_PU field.
	RTC_CNTL_DIG_PWC_LSLP_MEM_FORCE_PU_Pos = 0x4
	// Bit mask of LSLP_MEM_FORCE_PU field.
	RTC_CNTL_DIG_PWC_LSLP_MEM_FORCE_PU_Msk = 0x10
	// Bit LSLP_MEM_FORCE_PU.
	RTC_CNTL_DIG_PWC_LSLP_MEM_FORCE_PU = 0x10
	// Position of ROM0_FORCE_PD field.
	RTC_CNTL_DIG_PWC_ROM0_FORCE_PD_Pos = 0x5
	// Bit mask of ROM0_FORCE_PD field.
	RTC_CNTL_DIG_PWC_ROM0_FORCE_PD_Msk = 0x20
	// Bit ROM0_FORCE_PD.
	RTC_CNTL_DIG_PWC_ROM0_FORCE_PD = 0x20
	// Position of ROM0_FORCE_PU field.
	RTC_CNTL_DIG_PWC_ROM0_FORCE_PU_Pos = 0x6
	// Bit mask of ROM0_FORCE_PU field.
	RTC_CNTL_DIG_PWC_ROM0_FORCE_PU_Msk = 0x40
	// Bit ROM0_FORCE_PU.
	RTC_CNTL_DIG_PWC_ROM0_FORCE_PU = 0x40
	// Position of INTER_RAM0_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM0_FORCE_PD_Pos = 0x7
	// Bit mask of INTER_RAM0_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM0_FORCE_PD_Msk = 0x80
	// Bit INTER_RAM0_FORCE_PD.
	RTC_CNTL_DIG_PWC_INTER_RAM0_FORCE_PD = 0x80
	// Position of INTER_RAM0_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM0_FORCE_PU_Pos = 0x8
	// Bit mask of INTER_RAM0_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM0_FORCE_PU_Msk = 0x100
	// Bit INTER_RAM0_FORCE_PU.
	RTC_CNTL_DIG_PWC_INTER_RAM0_FORCE_PU = 0x100
	// Position of INTER_RAM1_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM1_FORCE_PD_Pos = 0x9
	// Bit mask of INTER_RAM1_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM1_FORCE_PD_Msk = 0x200
	// Bit INTER_RAM1_FORCE_PD.
	RTC_CNTL_DIG_PWC_INTER_RAM1_FORCE_PD = 0x200
	// Position of INTER_RAM1_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM1_FORCE_PU_Pos = 0xa
	// Bit mask of INTER_RAM1_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM1_FORCE_PU_Msk = 0x400
	// Bit INTER_RAM1_FORCE_PU.
	RTC_CNTL_DIG_PWC_INTER_RAM1_FORCE_PU = 0x400
	// Position of INTER_RAM2_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM2_FORCE_PD_Pos = 0xb
	// Bit mask of INTER_RAM2_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM2_FORCE_PD_Msk = 0x800
	// Bit INTER_RAM2_FORCE_PD.
	RTC_CNTL_DIG_PWC_INTER_RAM2_FORCE_PD = 0x800
	// Position of INTER_RAM2_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM2_FORCE_PU_Pos = 0xc
	// Bit mask of INTER_RAM2_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM2_FORCE_PU_Msk = 0x1000
	// Bit INTER_RAM2_FORCE_PU.
	RTC_CNTL_DIG_PWC_INTER_RAM2_FORCE_PU = 0x1000
	// Position of INTER_RAM3_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM3_FORCE_PD_Pos = 0xd
	// Bit mask of INTER_RAM3_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM3_FORCE_PD_Msk = 0x2000
	// Bit INTER_RAM3_FORCE_PD.
	RTC_CNTL_DIG_PWC_INTER_RAM3_FORCE_PD = 0x2000
	// Position of INTER_RAM3_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM3_FORCE_PU_Pos = 0xe
	// Bit mask of INTER_RAM3_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM3_FORCE_PU_Msk = 0x4000
	// Bit INTER_RAM3_FORCE_PU.
	RTC_CNTL_DIG_PWC_INTER_RAM3_FORCE_PU = 0x4000
	// Position of INTER_RAM4_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM4_FORCE_PD_Pos = 0xf
	// Bit mask of INTER_RAM4_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM4_FORCE_PD_Msk = 0x8000
	// Bit INTER_RAM4_FORCE_PD.
	RTC_CNTL_DIG_PWC_INTER_RAM4_FORCE_PD = 0x8000
	// Position of INTER_RAM4_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM4_FORCE_PU_Pos = 0x10
	// Bit mask of INTER_RAM4_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM4_FORCE_PU_Msk = 0x10000
	// Bit INTER_RAM4_FORCE_PU.
	RTC_CNTL_DIG_PWC_INTER_RAM4_FORCE_PU = 0x10000
	// Position of WIFI_FORCE_PD field.
	RTC_CNTL_DIG_PWC_WIFI_FORCE_PD_Pos = 0x11
	// Bit mask of WIFI_FORCE_PD field.
	RTC_CNTL_DIG_PWC_WIFI_FORCE_PD_Msk = 0x20000
	// Bit WIFI_FORCE_PD.
	RTC_CNTL_DIG_PWC_WIFI_FORCE_PD = 0x20000
	// Position of WIFI_FORCE_PU field.
	RTC_CNTL_DIG_PWC_WIFI_FORCE_PU_Pos = 0x12
	// Bit mask of WIFI_FORCE_PU field.
	RTC_CNTL_DIG_PWC_WIFI_FORCE_PU_Msk = 0x40000
	// Bit WIFI_FORCE_PU.
	RTC_CNTL_DIG_PWC_WIFI_FORCE_PU = 0x40000
	// Position of DG_WRAP_FORCE_PD field.
	RTC_CNTL_DIG_PWC_DG_WRAP_FORCE_PD_Pos = 0x13
	// Bit mask of DG_WRAP_FORCE_PD field.
	RTC_CNTL_DIG_PWC_DG_WRAP_FORCE_PD_Msk = 0x80000
	// Bit DG_WRAP_FORCE_PD.
	RTC_CNTL_DIG_PWC_DG_WRAP_FORCE_PD = 0x80000
	// Position of DG_WRAP_FORCE_PU field.
	RTC_CNTL_DIG_PWC_DG_WRAP_FORCE_PU_Pos = 0x14
	// Bit mask of DG_WRAP_FORCE_PU field.
	RTC_CNTL_DIG_PWC_DG_WRAP_FORCE_PU_Msk = 0x100000
	// Bit DG_WRAP_FORCE_PU.
	RTC_CNTL_DIG_PWC_DG_WRAP_FORCE_PU = 0x100000
	// Position of ROM0_PD_EN field.
	RTC_CNTL_DIG_PWC_ROM0_PD_EN_Pos = 0x18
	// Bit mask of ROM0_PD_EN field.
	RTC_CNTL_DIG_PWC_ROM0_PD_EN_Msk = 0x1000000
	// Bit ROM0_PD_EN.
	RTC_CNTL_DIG_PWC_ROM0_PD_EN = 0x1000000
	// Position of INTER_RAM0_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM0_PD_EN_Pos = 0x19
	// Bit mask of INTER_RAM0_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM0_PD_EN_Msk = 0x2000000
	// Bit INTER_RAM0_PD_EN.
	RTC_CNTL_DIG_PWC_INTER_RAM0_PD_EN = 0x2000000
	// Position of INTER_RAM1_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM1_PD_EN_Pos = 0x1a
	// Bit mask of INTER_RAM1_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM1_PD_EN_Msk = 0x4000000
	// Bit INTER_RAM1_PD_EN.
	RTC_CNTL_DIG_PWC_INTER_RAM1_PD_EN = 0x4000000
	// Position of INTER_RAM2_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM2_PD_EN_Pos = 0x1b
	// Bit mask of INTER_RAM2_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM2_PD_EN_Msk = 0x8000000
	// Bit INTER_RAM2_PD_EN.
	RTC_CNTL_DIG_PWC_INTER_RAM2_PD_EN = 0x8000000
	// Position of INTER_RAM3_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM3_PD_EN_Pos = 0x1c
	// Bit mask of INTER_RAM3_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM3_PD_EN_Msk = 0x10000000
	// Bit INTER_RAM3_PD_EN.
	RTC_CNTL_DIG_PWC_INTER_RAM3_PD_EN = 0x10000000
	// Position of INTER_RAM4_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM4_PD_EN_Pos = 0x1d
	// Bit mask of INTER_RAM4_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM4_PD_EN_Msk = 0x20000000
	// Bit INTER_RAM4_PD_EN.
	RTC_CNTL_DIG_PWC_INTER_RAM4_PD_EN = 0x20000000
	// Position of WIFI_PD_EN field.
	RTC_CNTL_DIG_PWC_WIFI_PD_EN_Pos = 0x1e
	// Bit mask of WIFI_PD_EN field.
	RTC_CNTL_DIG_PWC_WIFI_PD_EN_Msk = 0x40000000
	// Bit WIFI_PD_EN.
	RTC_CNTL_DIG_PWC_WIFI_PD_EN = 0x40000000
	// Position of DG_WRAP_PD_EN field.
	RTC_CNTL_DIG_PWC_DG_WRAP_PD_EN_Pos = 0x1f
	// Bit mask of DG_WRAP_PD_EN field.
	RTC_CNTL_DIG_PWC_DG_WRAP_PD_EN_Msk = 0x80000000
	// Bit DG_WRAP_PD_EN.
	RTC_CNTL_DIG_PWC_DG_WRAP_PD_EN = 0x80000000

	// DIG_ISO
	// Position of FORCE_OFF field.
	RTC_CNTL_DIG_ISO_FORCE_OFF_Pos = 0x7
	// Bit mask of FORCE_OFF field.
	RTC_CNTL_DIG_ISO_FORCE_OFF_Msk = 0x80
	// Bit FORCE_OFF.
	RTC_CNTL_DIG_ISO_FORCE_OFF = 0x80
	// Position of FORCE_ON field.
	RTC_CNTL_DIG_ISO_FORCE_ON_Pos = 0x8
	// Bit mask of FORCE_ON field.
	RTC_CNTL_DIG_ISO_FORCE_ON_Msk = 0x100
	// Bit FORCE_ON.
	RTC_CNTL_DIG_ISO_FORCE_ON = 0x100
	// Position of DG_PAD_AUTOHOLD field.
	RTC_CNTL_DIG_ISO_DG_PAD_AUTOHOLD_Pos = 0x9
	// Bit mask of DG_PAD_AUTOHOLD field.
	RTC_CNTL_DIG_ISO_DG_PAD_AUTOHOLD_Msk = 0x200
	// Bit DG_PAD_AUTOHOLD.
	RTC_CNTL_DIG_ISO_DG_PAD_AUTOHOLD = 0x200
	// Position of CLR_DG_PAD_AUTOHOLD field.
	RTC_CNTL_DIG_ISO_CLR_DG_PAD_AUTOHOLD_Pos = 0xa
	// Bit mask of CLR_DG_PAD_AUTOHOLD field.
	RTC_CNTL_DIG_ISO_CLR_DG_PAD_AUTOHOLD_Msk = 0x400
	// Bit CLR_DG_PAD_AUTOHOLD.
	RTC_CNTL_DIG_ISO_CLR_DG_PAD_AUTOHOLD = 0x400
	// Position of DG_PAD_AUTOHOLD_EN field.
	RTC_CNTL_DIG_ISO_DG_PAD_AUTOHOLD_EN_Pos = 0xb
	// Bit mask of DG_PAD_AUTOHOLD_EN field.
	RTC_CNTL_DIG_ISO_DG_PAD_AUTOHOLD_EN_Msk = 0x800
	// Bit DG_PAD_AUTOHOLD_EN.
	RTC_CNTL_DIG_ISO_DG_PAD_AUTOHOLD_EN = 0x800
	// Position of DG_PAD_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_NOISO_Pos = 0xc
	// Bit mask of DG_PAD_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_NOISO_Msk = 0x1000
	// Bit DG_PAD_FORCE_NOISO.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_NOISO = 0x1000
	// Position of DG_PAD_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_ISO_Pos = 0xd
	// Bit mask of DG_PAD_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_ISO_Msk = 0x2000
	// Bit DG_PAD_FORCE_ISO.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_ISO = 0x2000
	// Position of DG_PAD_FORCE_UNHOLD field.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_UNHOLD_Pos = 0xe
	// Bit mask of DG_PAD_FORCE_UNHOLD field.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_UNHOLD_Msk = 0x4000
	// Bit DG_PAD_FORCE_UNHOLD.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_UNHOLD = 0x4000
	// Position of DG_PAD_FORCE_HOLD field.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_HOLD_Pos = 0xf
	// Bit mask of DG_PAD_FORCE_HOLD field.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_HOLD_Msk = 0x8000
	// Bit DG_PAD_FORCE_HOLD.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_HOLD = 0x8000
	// Position of ROM0_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_ROM0_FORCE_ISO_Pos = 0x10
	// Bit mask of ROM0_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_ROM0_FORCE_ISO_Msk = 0x10000
	// Bit ROM0_FORCE_ISO.
	RTC_CNTL_DIG_ISO_ROM0_FORCE_ISO = 0x10000
	// Position of ROM0_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_ROM0_FORCE_NOISO_Pos = 0x11
	// Bit mask of ROM0_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_ROM0_FORCE_NOISO_Msk = 0x20000
	// Bit ROM0_FORCE_NOISO.
	RTC_CNTL_DIG_ISO_ROM0_FORCE_NOISO = 0x20000
	// Position of INTER_RAM0_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM0_FORCE_ISO_Pos = 0x12
	// Bit mask of INTER_RAM0_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM0_FORCE_ISO_Msk = 0x40000
	// Bit INTER_RAM0_FORCE_ISO.
	RTC_CNTL_DIG_ISO_INTER_RAM0_FORCE_ISO = 0x40000
	// Position of INTER_RAM0_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM0_FORCE_NOISO_Pos = 0x13
	// Bit mask of INTER_RAM0_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM0_FORCE_NOISO_Msk = 0x80000
	// Bit INTER_RAM0_FORCE_NOISO.
	RTC_CNTL_DIG_ISO_INTER_RAM0_FORCE_NOISO = 0x80000
	// Position of INTER_RAM1_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM1_FORCE_ISO_Pos = 0x14
	// Bit mask of INTER_RAM1_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM1_FORCE_ISO_Msk = 0x100000
	// Bit INTER_RAM1_FORCE_ISO.
	RTC_CNTL_DIG_ISO_INTER_RAM1_FORCE_ISO = 0x100000
	// Position of INTER_RAM1_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM1_FORCE_NOISO_Pos = 0x15
	// Bit mask of INTER_RAM1_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM1_FORCE_NOISO_Msk = 0x200000
	// Bit INTER_RAM1_FORCE_NOISO.
	RTC_CNTL_DIG_ISO_INTER_RAM1_FORCE_NOISO = 0x200000
	// Position of INTER_RAM2_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM2_FORCE_ISO_Pos = 0x16
	// Bit mask of INTER_RAM2_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM2_FORCE_ISO_Msk = 0x400000
	// Bit INTER_RAM2_FORCE_ISO.
	RTC_CNTL_DIG_ISO_INTER_RAM2_FORCE_ISO = 0x400000
	// Position of INTER_RAM2_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM2_FORCE_NOISO_Pos = 0x17
	// Bit mask of INTER_RAM2_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM2_FORCE_NOISO_Msk = 0x800000
	// Bit INTER_RAM2_FORCE_NOISO.
	RTC_CNTL_DIG_ISO_INTER_RAM2_FORCE_NOISO = 0x800000
	// Position of INTER_RAM3_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM3_FORCE_ISO_Pos = 0x18
	// Bit mask of INTER_RAM3_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM3_FORCE_ISO_Msk = 0x1000000
	// Bit INTER_RAM3_FORCE_ISO.
	RTC_CNTL_DIG_ISO_INTER_RAM3_FORCE_ISO = 0x1000000
	// Position of INTER_RAM3_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM3_FORCE_NOISO_Pos = 0x19
	// Bit mask of INTER_RAM3_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM3_FORCE_NOISO_Msk = 0x2000000
	// Bit INTER_RAM3_FORCE_NOISO.
	RTC_CNTL_DIG_ISO_INTER_RAM3_FORCE_NOISO = 0x2000000
	// Position of INTER_RAM4_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM4_FORCE_ISO_Pos = 0x1a
	// Bit mask of INTER_RAM4_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM4_FORCE_ISO_Msk = 0x4000000
	// Bit INTER_RAM4_FORCE_ISO.
	RTC_CNTL_DIG_ISO_INTER_RAM4_FORCE_ISO = 0x4000000
	// Position of INTER_RAM4_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM4_FORCE_NOISO_Pos = 0x1b
	// Bit mask of INTER_RAM4_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM4_FORCE_NOISO_Msk = 0x8000000
	// Bit INTER_RAM4_FORCE_NOISO.
	RTC_CNTL_DIG_ISO_INTER_RAM4_FORCE_NOISO = 0x8000000
	// Position of WIFI_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_WIFI_FORCE_ISO_Pos = 0x1c
	// Bit mask of WIFI_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_WIFI_FORCE_ISO_Msk = 0x10000000
	// Bit WIFI_FORCE_ISO.
	RTC_CNTL_DIG_ISO_WIFI_FORCE_ISO = 0x10000000
	// Position of WIFI_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_WIFI_FORCE_NOISO_Pos = 0x1d
	// Bit mask of WIFI_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_WIFI_FORCE_NOISO_Msk = 0x20000000
	// Bit WIFI_FORCE_NOISO.
	RTC_CNTL_DIG_ISO_WIFI_FORCE_NOISO = 0x20000000
	// Position of DG_WRAP_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_DG_WRAP_FORCE_ISO_Pos = 0x1e
	// Bit mask of DG_WRAP_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_DG_WRAP_FORCE_ISO_Msk = 0x40000000
	// Bit DG_WRAP_FORCE_ISO.
	RTC_CNTL_DIG_ISO_DG_WRAP_FORCE_ISO = 0x40000000
	// Position of DG_WRAP_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_DG_WRAP_FORCE_NOISO_Pos = 0x1f
	// Bit mask of DG_WRAP_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_DG_WRAP_FORCE_NOISO_Msk = 0x80000000
	// Bit DG_WRAP_FORCE_NOISO.
	RTC_CNTL_DIG_ISO_DG_WRAP_FORCE_NOISO = 0x80000000

	// WDTCONFIG0
	// Position of WDT_PAUSE_IN_SLP field.
	RTC_CNTL_WDTCONFIG0_WDT_PAUSE_IN_SLP_Pos = 0x7
	// Bit mask of WDT_PAUSE_IN_SLP field.
	RTC_CNTL_WDTCONFIG0_WDT_PAUSE_IN_SLP_Msk = 0x80
	// Bit WDT_PAUSE_IN_SLP.
	RTC_CNTL_WDTCONFIG0_WDT_PAUSE_IN_SLP = 0x80
	// Position of WDT_APPCPU_RESET_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_APPCPU_RESET_EN_Pos = 0x8
	// Bit mask of WDT_APPCPU_RESET_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_APPCPU_RESET_EN_Msk = 0x100
	// Bit WDT_APPCPU_RESET_EN.
	RTC_CNTL_WDTCONFIG0_WDT_APPCPU_RESET_EN = 0x100
	// Position of WDT_PROCPU_RESET_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_PROCPU_RESET_EN_Pos = 0x9
	// Bit mask of WDT_PROCPU_RESET_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_PROCPU_RESET_EN_Msk = 0x200
	// Bit WDT_PROCPU_RESET_EN.
	RTC_CNTL_WDTCONFIG0_WDT_PROCPU_RESET_EN = 0x200
	// Position of WDT_FLASHBOOT_MOD_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_FLASHBOOT_MOD_EN_Pos = 0xa
	// Bit mask of WDT_FLASHBOOT_MOD_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_FLASHBOOT_MOD_EN_Msk = 0x400
	// Bit WDT_FLASHBOOT_MOD_EN.
	RTC_CNTL_WDTCONFIG0_WDT_FLASHBOOT_MOD_EN = 0x400
	// Position of WDT_SYS_RESET_LENGTH field.
	RTC_CNTL_WDTCONFIG0_WDT_SYS_RESET_LENGTH_Pos = 0xb
	// Bit mask of WDT_SYS_RESET_LENGTH field.
	RTC_CNTL_WDTCONFIG0_WDT_SYS_RESET_LENGTH_Msk = 0x3800
	// Position of WDT_CPU_RESET_LENGTH field.
	RTC_CNTL_WDTCONFIG0_WDT_CPU_RESET_LENGTH_Pos = 0xe
	// Bit mask of WDT_CPU_RESET_LENGTH field.
	RTC_CNTL_WDTCONFIG0_WDT_CPU_RESET_LENGTH_Msk = 0x1c000
	// Position of WDT_LEVEL_INT_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_LEVEL_INT_EN_Pos = 0x11
	// Bit mask of WDT_LEVEL_INT_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_LEVEL_INT_EN_Msk = 0x20000
	// Bit WDT_LEVEL_INT_EN.
	RTC_CNTL_WDTCONFIG0_WDT_LEVEL_INT_EN = 0x20000
	// Position of WDT_EDGE_INT_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_EDGE_INT_EN_Pos = 0x12
	// Bit mask of WDT_EDGE_INT_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_EDGE_INT_EN_Msk = 0x40000
	// Bit WDT_EDGE_INT_EN.
	RTC_CNTL_WDTCONFIG0_WDT_EDGE_INT_EN = 0x40000
	// Position of WDT_STG3 field.
	RTC_CNTL_WDTCONFIG0_WDT_STG3_Pos = 0x13
	// Bit mask of WDT_STG3 field.
	RTC_CNTL_WDTCONFIG0_WDT_STG3_Msk = 0x380000
	// Position of WDT_STG2 field.
	RTC_CNTL_WDTCONFIG0_WDT_STG2_Pos = 0x16
	// Bit mask of WDT_STG2 field.
	RTC_CNTL_WDTCONFIG0_WDT_STG2_Msk = 0x1c00000
	// Position of WDT_STG1 field.
	RTC_CNTL_WDTCONFIG0_WDT_STG1_Pos = 0x19
	// Bit mask of WDT_STG1 field.
	RTC_CNTL_WDTCONFIG0_WDT_STG1_Msk = 0xe000000
	// Position of WDT_STG0 field.
	RTC_CNTL_WDTCONFIG0_WDT_STG0_Pos = 0x1c
	// Bit mask of WDT_STG0 field.
	RTC_CNTL_WDTCONFIG0_WDT_STG0_Msk = 0x70000000
	// Position of WDT_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_EN_Pos = 0x1f
	// Bit mask of WDT_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_EN_Msk = 0x80000000
	// Bit WDT_EN.
	RTC_CNTL_WDTCONFIG0_WDT_EN = 0x80000000

	// WDTCONFIG1
	// Position of WDT_STG0_HOLD field.
	RTC_CNTL_WDTCONFIG1_WDT_STG0_HOLD_Pos = 0x0
	// Bit mask of WDT_STG0_HOLD field.
	RTC_CNTL_WDTCONFIG1_WDT_STG0_HOLD_Msk = 0xffffffff

	// WDTCONFIG2
	// Position of WDT_STG1_HOLD field.
	RTC_CNTL_WDTCONFIG2_WDT_STG1_HOLD_Pos = 0x0
	// Bit mask of WDT_STG1_HOLD field.
	RTC_CNTL_WDTCONFIG2_WDT_STG1_HOLD_Msk = 0xffffffff

	// WDTCONFIG3
	// Position of WDT_STG2_HOLD field.
	RTC_CNTL_WDTCONFIG3_WDT_STG2_HOLD_Pos = 0x0
	// Bit mask of WDT_STG2_HOLD field.
	RTC_CNTL_WDTCONFIG3_WDT_STG2_HOLD_Msk = 0xffffffff

	// WDTCONFIG4
	// Position of WDT_STG3_HOLD field.
	RTC_CNTL_WDTCONFIG4_WDT_STG3_HOLD_Pos = 0x0
	// Bit mask of WDT_STG3_HOLD field.
	RTC_CNTL_WDTCONFIG4_WDT_STG3_HOLD_Msk = 0xffffffff

	// WDTFEED
	// Position of WDT_FEED field.
	RTC_CNTL_WDTFEED_WDT_FEED_Pos = 0x1f
	// Bit mask of WDT_FEED field.
	RTC_CNTL_WDTFEED_WDT_FEED_Msk = 0x80000000
	// Bit WDT_FEED.
	RTC_CNTL_WDTFEED_WDT_FEED = 0x80000000

	// WDTWPROTECT
	// Position of WDT_WKEY field.
	RTC_CNTL_WDTWPROTECT_WDT_WKEY_Pos = 0x0
	// Bit mask of WDT_WKEY field.
	RTC_CNTL_WDTWPROTECT_WDT_WKEY_Msk = 0xffffffff

	// TEST_MUX
	// Position of ENT_RTC field.
	RTC_CNTL_TEST_MUX_ENT_RTC_Pos = 0x1d
	// Bit mask of ENT_RTC field.
	RTC_CNTL_TEST_MUX_ENT_RTC_Msk = 0x20000000
	// Bit ENT_RTC.
	RTC_CNTL_TEST_MUX_ENT_RTC = 0x20000000
	// Position of DTEST_RTC field.
	RTC_CNTL_TEST_MUX_DTEST_RTC_Pos = 0x1e
	// Bit mask of DTEST_RTC field.
	RTC_CNTL_TEST_MUX_DTEST_RTC_Msk = 0xc0000000

	// SW_CPU_STALL
	// Position of SW_STALL_APPCPU_C1 field.
	RTC_CNTL_SW_CPU_STALL_SW_STALL_APPCPU_C1_Pos = 0x14
	// Bit mask of SW_STALL_APPCPU_C1 field.
	RTC_CNTL_SW_CPU_STALL_SW_STALL_APPCPU_C1_Msk = 0x3f00000
	// Position of SW_STALL_PROCPU_C1 field.
	RTC_CNTL_SW_CPU_STALL_SW_STALL_PROCPU_C1_Pos = 0x1a
	// Bit mask of SW_STALL_PROCPU_C1 field.
	RTC_CNTL_SW_CPU_STALL_SW_STALL_PROCPU_C1_Msk = 0xfc000000

	// STORE4
	// Position of SCRATCH4 field.
	RTC_CNTL_STORE4_SCRATCH4_Pos = 0x0
	// Bit mask of SCRATCH4 field.
	RTC_CNTL_STORE4_SCRATCH4_Msk = 0xffffffff

	// STORE5
	// Position of SCRATCH5 field.
	RTC_CNTL_STORE5_SCRATCH5_Pos = 0x0
	// Bit mask of SCRATCH5 field.
	RTC_CNTL_STORE5_SCRATCH5_Msk = 0xffffffff

	// STORE6
	// Position of SCRATCH6 field.
	RTC_CNTL_STORE6_SCRATCH6_Pos = 0x0
	// Bit mask of SCRATCH6 field.
	RTC_CNTL_STORE6_SCRATCH6_Msk = 0xffffffff

	// STORE7
	// Position of SCRATCH7 field.
	RTC_CNTL_STORE7_SCRATCH7_Pos = 0x0
	// Bit mask of SCRATCH7 field.
	RTC_CNTL_STORE7_SCRATCH7_Msk = 0xffffffff

	// LOW_POWER_ST
	// Position of LOW_POWER_DIAG0 field.
	RTC_CNTL_LOW_POWER_ST_LOW_POWER_DIAG0_Pos = 0x0
	// Bit mask of LOW_POWER_DIAG0 field.
	RTC_CNTL_LOW_POWER_ST_LOW_POWER_DIAG0_Msk = 0xffffffff
	// Position of RDY_FOR_WAKEUP field.
	RTC_CNTL_LOW_POWER_ST_RDY_FOR_WAKEUP_Pos = 0x13
	// Bit mask of RDY_FOR_WAKEUP field.
	RTC_CNTL_LOW_POWER_ST_RDY_FOR_WAKEUP_Msk = 0x80000
	// Bit RDY_FOR_WAKEUP.
	RTC_CNTL_LOW_POWER_ST_RDY_FOR_WAKEUP = 0x80000

	// DIAG1
	// Position of LOW_POWER_DIAG1 field.
	RTC_CNTL_DIAG1_LOW_POWER_DIAG1_Pos = 0x0
	// Bit mask of LOW_POWER_DIAG1 field.
	RTC_CNTL_DIAG1_LOW_POWER_DIAG1_Msk = 0xffffffff

	// HOLD_FORCE
	// Position of ADC1_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_ADC1_HOLD_FORCE_Pos = 0x0
	// Bit mask of ADC1_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_ADC1_HOLD_FORCE_Msk = 0x1
	// Bit ADC1_HOLD_FORCE.
	RTC_CNTL_HOLD_FORCE_ADC1_HOLD_FORCE = 0x1
	// Position of ADC2_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_ADC2_HOLD_FORCE_Pos = 0x1
	// Bit mask of ADC2_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_ADC2_HOLD_FORCE_Msk = 0x2
	// Bit ADC2_HOLD_FORCE.
	RTC_CNTL_HOLD_FORCE_ADC2_HOLD_FORCE = 0x2
	// Position of PDAC1_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_PDAC1_HOLD_FORCE_Pos = 0x2
	// Bit mask of PDAC1_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_PDAC1_HOLD_FORCE_Msk = 0x4
	// Bit PDAC1_HOLD_FORCE.
	RTC_CNTL_HOLD_FORCE_PDAC1_HOLD_FORCE = 0x4
	// Position of PDAC2_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_PDAC2_HOLD_FORCE_Pos = 0x3
	// Bit mask of PDAC2_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_PDAC2_HOLD_FORCE_Msk = 0x8
	// Bit PDAC2_HOLD_FORCE.
	RTC_CNTL_HOLD_FORCE_PDAC2_HOLD_FORCE = 0x8
	// Position of SENSE1_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_SENSE1_HOLD_FORCE_Pos = 0x4
	// Bit mask of SENSE1_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_SENSE1_HOLD_FORCE_Msk = 0x10
	// Bit SENSE1_HOLD_FORCE.
	RTC_CNTL_HOLD_FORCE_SENSE1_HOLD_FORCE = 0x10
	// Position of SENSE2_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_SENSE2_HOLD_FORCE_Pos = 0x5
	// Bit mask of SENSE2_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_SENSE2_HOLD_FORCE_Msk = 0x20
	// Bit SENSE2_HOLD_FORCE.
	RTC_CNTL_HOLD_FORCE_SENSE2_HOLD_FORCE = 0x20
	// Position of SENSE3_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_SENSE3_HOLD_FORCE_Pos = 0x6
	// Bit mask of SENSE3_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_SENSE3_HOLD_FORCE_Msk = 0x40
	// Bit SENSE3_HOLD_FORCE.
	RTC_CNTL_HOLD_FORCE_SENSE3_HOLD_FORCE = 0x40
	// Position of SENSE4_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_SENSE4_HOLD_FORCE_Pos = 0x7
	// Bit mask of SENSE4_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_SENSE4_HOLD_FORCE_Msk = 0x80
	// Bit SENSE4_HOLD_FORCE.
	RTC_CNTL_HOLD_FORCE_SENSE4_HOLD_FORCE = 0x80
	// Position of TOUCH_PAD0_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_TOUCH_PAD0_HOLD_FORCE_Pos = 0x8
	// Bit mask of TOUCH_PAD0_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_TOUCH_PAD0_HOLD_FORCE_Msk = 0x100
	// Bit TOUCH_PAD0_HOLD_FORCE.
	RTC_CNTL_HOLD_FORCE_TOUCH_PAD0_HOLD_FORCE = 0x100
	// Position of TOUCH_PAD1_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_TOUCH_PAD1_HOLD_FORCE_Pos = 0x9
	// Bit mask of TOUCH_PAD1_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_TOUCH_PAD1_HOLD_FORCE_Msk = 0x200
	// Bit TOUCH_PAD1_HOLD_FORCE.
	RTC_CNTL_HOLD_FORCE_TOUCH_PAD1_HOLD_FORCE = 0x200
	// Position of TOUCH_PAD2_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_TOUCH_PAD2_HOLD_FORCE_Pos = 0xa
	// Bit mask of TOUCH_PAD2_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_TOUCH_PAD2_HOLD_FORCE_Msk = 0x400
	// Bit TOUCH_PAD2_HOLD_FORCE.
	RTC_CNTL_HOLD_FORCE_TOUCH_PAD2_HOLD_FORCE = 0x400
	// Position of TOUCH_PAD3_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_TOUCH_PAD3_HOLD_FORCE_Pos = 0xb
	// Bit mask of TOUCH_PAD3_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_TOUCH_PAD3_HOLD_FORCE_Msk = 0x800
	// Bit TOUCH_PAD3_HOLD_FORCE.
	RTC_CNTL_HOLD_FORCE_TOUCH_PAD3_HOLD_FORCE = 0x800
	// Position of TOUCH_PAD4_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_TOUCH_PAD4_HOLD_FORCE_Pos = 0xc
	// Bit mask of TOUCH_PAD4_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_TOUCH_PAD4_HOLD_FORCE_Msk = 0x1000
	// Bit TOUCH_PAD4_HOLD_FORCE.
	RTC_CNTL_HOLD_FORCE_TOUCH_PAD4_HOLD_FORCE = 0x1000
	// Position of TOUCH_PAD5_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_TOUCH_PAD5_HOLD_FORCE_Pos = 0xd
	// Bit mask of TOUCH_PAD5_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_TOUCH_PAD5_HOLD_FORCE_Msk = 0x2000
	// Bit TOUCH_PAD5_HOLD_FORCE.
	RTC_CNTL_HOLD_FORCE_TOUCH_PAD5_HOLD_FORCE = 0x2000
	// Position of TOUCH_PAD6_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_TOUCH_PAD6_HOLD_FORCE_Pos = 0xe
	// Bit mask of TOUCH_PAD6_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_TOUCH_PAD6_HOLD_FORCE_Msk = 0x4000
	// Bit TOUCH_PAD6_HOLD_FORCE.
	RTC_CNTL_HOLD_FORCE_TOUCH_PAD6_HOLD_FORCE = 0x4000
	// Position of TOUCH_PAD7_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_TOUCH_PAD7_HOLD_FORCE_Pos = 0xf
	// Bit mask of TOUCH_PAD7_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_TOUCH_PAD7_HOLD_FORCE_Msk = 0x8000
	// Bit TOUCH_PAD7_HOLD_FORCE.
	RTC_CNTL_HOLD_FORCE_TOUCH_PAD7_HOLD_FORCE = 0x8000
	// Position of X32P_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_X32P_HOLD_FORCE_Pos = 0x10
	// Bit mask of X32P_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_X32P_HOLD_FORCE_Msk = 0x10000
	// Bit X32P_HOLD_FORCE.
	RTC_CNTL_HOLD_FORCE_X32P_HOLD_FORCE = 0x10000
	// Position of X32N_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_X32N_HOLD_FORCE_Pos = 0x11
	// Bit mask of X32N_HOLD_FORCE field.
	RTC_CNTL_HOLD_FORCE_X32N_HOLD_FORCE_Msk = 0x20000
	// Bit X32N_HOLD_FORCE.
	RTC_CNTL_HOLD_FORCE_X32N_HOLD_FORCE = 0x20000

	// EXT_WAKEUP1
	// Position of SEL field.
	RTC_CNTL_EXT_WAKEUP1_SEL_Pos = 0x0
	// Bit mask of SEL field.
	RTC_CNTL_EXT_WAKEUP1_SEL_Msk = 0x3ffff
	// Position of STATUS_CLR field.
	RTC_CNTL_EXT_WAKEUP1_STATUS_CLR_Pos = 0x12
	// Bit mask of STATUS_CLR field.
	RTC_CNTL_EXT_WAKEUP1_STATUS_CLR_Msk = 0x40000
	// Bit STATUS_CLR.
	RTC_CNTL_EXT_WAKEUP1_STATUS_CLR = 0x40000

	// EXT_WAKEUP1_STATUS
	// Position of EXT_WAKEUP1_STATUS field.
	RTC_CNTL_EXT_WAKEUP1_STATUS_EXT_WAKEUP1_STATUS_Pos = 0x0
	// Bit mask of EXT_WAKEUP1_STATUS field.
	RTC_CNTL_EXT_WAKEUP1_STATUS_EXT_WAKEUP1_STATUS_Msk = 0x3ffff

	// BROWN_OUT
	// Position of RTC_MEM_PID_CONF field.
	RTC_CNTL_BROWN_OUT_RTC_MEM_PID_CONF_Pos = 0x0
	// Bit mask of RTC_MEM_PID_CONF field.
	RTC_CNTL_BROWN_OUT_RTC_MEM_PID_CONF_Msk = 0xff
	// Position of RTC_MEM_CRC_START field.
	RTC_CNTL_BROWN_OUT_RTC_MEM_CRC_START_Pos = 0x8
	// Bit mask of RTC_MEM_CRC_START field.
	RTC_CNTL_BROWN_OUT_RTC_MEM_CRC_START_Msk = 0x100
	// Bit RTC_MEM_CRC_START.
	RTC_CNTL_BROWN_OUT_RTC_MEM_CRC_START = 0x100
	// Position of RTC_MEM_CRC_ADDR field.
	RTC_CNTL_BROWN_OUT_RTC_MEM_CRC_ADDR_Pos = 0x9
	// Bit mask of RTC_MEM_CRC_ADDR field.
	RTC_CNTL_BROWN_OUT_RTC_MEM_CRC_ADDR_Msk = 0xffe00
	// Position of CLOSE_FLASH_ENA field.
	RTC_CNTL_BROWN_OUT_CLOSE_FLASH_ENA_Pos = 0xe
	// Bit mask of CLOSE_FLASH_ENA field.
	RTC_CNTL_BROWN_OUT_CLOSE_FLASH_ENA_Msk = 0x4000
	// Bit CLOSE_FLASH_ENA.
	RTC_CNTL_BROWN_OUT_CLOSE_FLASH_ENA = 0x4000
	// Position of PD_RF_ENA field.
	RTC_CNTL_BROWN_OUT_PD_RF_ENA_Pos = 0xf
	// Bit mask of PD_RF_ENA field.
	RTC_CNTL_BROWN_OUT_PD_RF_ENA_Msk = 0x8000
	// Bit PD_RF_ENA.
	RTC_CNTL_BROWN_OUT_PD_RF_ENA = 0x8000
	// Position of RST_WAIT field.
	RTC_CNTL_BROWN_OUT_RST_WAIT_Pos = 0x10
	// Bit mask of RST_WAIT field.
	RTC_CNTL_BROWN_OUT_RST_WAIT_Msk = 0x3ff0000
	// Position of RTC_MEM_CRC_LEN field.
	RTC_CNTL_BROWN_OUT_RTC_MEM_CRC_LEN_Pos = 0x14
	// Bit mask of RTC_MEM_CRC_LEN field.
	RTC_CNTL_BROWN_OUT_RTC_MEM_CRC_LEN_Msk = 0x7ff00000
	// Position of RST_ENA field.
	RTC_CNTL_BROWN_OUT_RST_ENA_Pos = 0x1a
	// Bit mask of RST_ENA field.
	RTC_CNTL_BROWN_OUT_RST_ENA_Msk = 0x4000000
	// Bit RST_ENA.
	RTC_CNTL_BROWN_OUT_RST_ENA = 0x4000000
	// Position of DBROWN_OUT_THRES field.
	RTC_CNTL_BROWN_OUT_DBROWN_OUT_THRES_Pos = 0x1b
	// Bit mask of DBROWN_OUT_THRES field.
	RTC_CNTL_BROWN_OUT_DBROWN_OUT_THRES_Msk = 0x38000000
	// Position of ENA field.
	RTC_CNTL_BROWN_OUT_ENA_Pos = 0x1e
	// Bit mask of ENA field.
	RTC_CNTL_BROWN_OUT_ENA_Msk = 0x40000000
	// Bit ENA.
	RTC_CNTL_BROWN_OUT_ENA = 0x40000000
	// Position of DET field.
	RTC_CNTL_BROWN_OUT_DET_Pos = 0x1f
	// Bit mask of DET field.
	RTC_CNTL_BROWN_OUT_DET_Msk = 0x80000000
	// Bit DET.
	RTC_CNTL_BROWN_OUT_DET = 0x80000000
	// Position of RTC_MEM_CRC_FINISH field.
	RTC_CNTL_BROWN_OUT_RTC_MEM_CRC_FINISH_Pos = 0x1f
	// Bit mask of RTC_MEM_CRC_FINISH field.
	RTC_CNTL_BROWN_OUT_RTC_MEM_CRC_FINISH_Msk = 0x80000000
	// Bit RTC_MEM_CRC_FINISH.
	RTC_CNTL_BROWN_OUT_RTC_MEM_CRC_FINISH = 0x80000000

	// DATE
	// Position of CNTL_DATE field.
	RTC_CNTL_DATE_CNTL_DATE_Pos = 0x0
	// Bit mask of CNTL_DATE field.
	RTC_CNTL_DATE_CNTL_DATE_Msk = 0xfffffff
)

// Real-Time Clock Control
type RTC_CNTL_Type struct {
	OPTIONS0           volatile.Register32 // 0x0
	SLP_TIMER0         volatile.Register32 // 0x4
	SLP_TIMER1         volatile.Register32 // 0x8
	TIME_UPDATE        volatile.Register32 // 0xC
	TIME0              volatile.Register32 // 0x10
	TIME1              volatile.Register32 // 0x14
	STATE0             volatile.Register32 // 0x18
	TIMER1             volatile.Register32 // 0x1C
	TIMER2             volatile.Register32 // 0x20
	TIMER3             volatile.Register32 // 0x24
	TIMER4             volatile.Register32 // 0x28
	TIMER5             volatile.Register32 // 0x2C
	ANA_CONF           volatile.Register32 // 0x30
	RESET_STATE        volatile.Register32 // 0x34
	WAKEUP_STATE       volatile.Register32 // 0x38
	INT_ENA            volatile.Register32 // 0x3C
	INT_RAW            volatile.Register32 // 0x40
	INT_ST             volatile.Register32 // 0x44
	INT_CLR            volatile.Register32 // 0x48
	STORE0             volatile.Register32 // 0x4C
	STORE1             volatile.Register32 // 0x50
	STORE2             volatile.Register32 // 0x54
	STORE3             volatile.Register32 // 0x58
	EXT_XTL_CONF       volatile.Register32 // 0x5C
	EXT_WAKEUP_CONF    volatile.Register32 // 0x60
	SLP_REJECT_CONF    volatile.Register32 // 0x64
	CPU_PERIOD_CONF    volatile.Register32 // 0x68
	SDIO_ACT_CONF      volatile.Register32 // 0x6C
	CLK_CONF           volatile.Register32 // 0x70
	SDIO_CONF          volatile.Register32 // 0x74
	BIAS_CONF          volatile.Register32 // 0x78
	REG                volatile.Register32 // 0x7C
	PWC                volatile.Register32 // 0x80
	DIG_PWC            volatile.Register32 // 0x84
	DIG_ISO            volatile.Register32 // 0x88
	WDTCONFIG0         volatile.Register32 // 0x8C
	WDTCONFIG1         volatile.Register32 // 0x90
	WDTCONFIG2         volatile.Register32 // 0x94
	WDTCONFIG3         volatile.Register32 // 0x98
	WDTCONFIG4         volatile.Register32 // 0x9C
	WDTFEED            volatile.Register32 // 0xA0
	WDTWPROTECT        volatile.Register32 // 0xA4
	TEST_MUX           volatile.Register32 // 0xA8
	SW_CPU_STALL       volatile.Register32 // 0xAC
	STORE4             volatile.Register32 // 0xB0
	STORE5             volatile.Register32 // 0xB4
	STORE6             volatile.Register32 // 0xB8
	STORE7             volatile.Register32 // 0xBC
	LOW_POWER_ST       volatile.Register32 // 0xC0
	DIAG1              volatile.Register32 // 0xC4
	HOLD_FORCE         volatile.Register32 // 0xC8
	EXT_WAKEUP1        volatile.Register32 // 0xCC
	EXT_WAKEUP1_STATUS volatile.Register32 // 0xD0
	BROWN_OUT          volatile.Register32 // 0xD4
	_                  [100]byte
	DATE               volatile.Register32 // 0x13C
}

// RTC_CNTL.OPTIONS0
func (o *RTC_CNTL_Type) SetOPTIONS0_SW_STALL_APPCPU_C0(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x3)|value)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_SW_STALL_APPCPU_C0() uint32 {
	return volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x3
}
func (o *RTC_CNTL_Type) SetOPTIONS0_SW_STALL_PROCPU_C0(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0xc)|value<<2)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_SW_STALL_PROCPU_C0() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0xc) >> 2
}
func (o *RTC_CNTL_Type) SetOPTIONS0_SW_APPCPU_RST(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_SW_APPCPU_RST() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetOPTIONS0_SW_PROCPU_RST(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_SW_PROCPU_RST() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetOPTIONS0_BB_I2C_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_BB_I2C_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetOPTIONS0_BB_I2C_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_BB_I2C_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetOPTIONS0_BBPLL_I2C_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_BBPLL_I2C_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetOPTIONS0_BBPLL_I2C_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_BBPLL_I2C_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetOPTIONS0_BBPLL_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_BBPLL_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetOPTIONS0_BBPLL_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_BBPLL_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetOPTIONS0_XTL_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_XTL_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetOPTIONS0_XTL_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_XTL_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetOPTIONS0_BIAS_SLEEP_FOLW_8M(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_BIAS_SLEEP_FOLW_8M() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetOPTIONS0_BIAS_FORCE_SLEEP(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_BIAS_FORCE_SLEEP() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetOPTIONS0_BIAS_FORCE_NOSLEEP(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_BIAS_FORCE_NOSLEEP() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetOPTIONS0_BIAS_I2C_FOLW_8M(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_BIAS_I2C_FOLW_8M() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x20000) >> 17
}
func (o *RTC_CNTL_Type) SetOPTIONS0_BIAS_I2C_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_BIAS_I2C_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x40000) >> 18
}
func (o *RTC_CNTL_Type) SetOPTIONS0_BIAS_I2C_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_BIAS_I2C_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x80000) >> 19
}
func (o *RTC_CNTL_Type) SetOPTIONS0_BIAS_CORE_FOLW_8M(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_BIAS_CORE_FOLW_8M() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x100000) >> 20
}
func (o *RTC_CNTL_Type) SetOPTIONS0_BIAS_CORE_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x200000)|value<<21)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_BIAS_CORE_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x200000) >> 21
}
func (o *RTC_CNTL_Type) SetOPTIONS0_BIAS_CORE_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_BIAS_CORE_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x400000) >> 22
}
func (o *RTC_CNTL_Type) SetOPTIONS0_XTL_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_XTL_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x800000) >> 23
}
func (o *RTC_CNTL_Type) SetOPTIONS0_PLL_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_PLL_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x1000000) >> 24
}
func (o *RTC_CNTL_Type) SetOPTIONS0_ANALOG_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x2000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_ANALOG_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x2000000) >> 25
}
func (o *RTC_CNTL_Type) SetOPTIONS0_XTL_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_XTL_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x4000000) >> 26
}
func (o *RTC_CNTL_Type) SetOPTIONS0_PLL_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x8000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_PLL_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x8000000) >> 27
}
func (o *RTC_CNTL_Type) SetOPTIONS0_ANALOG_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_ANALOG_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x10000000) >> 28
}
func (o *RTC_CNTL_Type) SetOPTIONS0_DG_WRAP_FORCE_RST(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_DG_WRAP_FORCE_RST() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetOPTIONS0_DG_WRAP_FORCE_NORST(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_DG_WRAP_FORCE_NORST() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetOPTIONS0_SW_SYS_RST(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_SW_SYS_RST() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.SLP_TIMER0
func (o *RTC_CNTL_Type) SetSLP_TIMER0(value uint32) {
	volatile.StoreUint32(&o.SLP_TIMER0.Reg, value)
}
func (o *RTC_CNTL_Type) GetSLP_TIMER0() uint32 {
	return volatile.LoadUint32(&o.SLP_TIMER0.Reg)
}

// RTC_CNTL.SLP_TIMER1
func (o *RTC_CNTL_Type) SetSLP_TIMER1_SLP_VAL_HI(value uint32) {
	volatile.StoreUint32(&o.SLP_TIMER1.Reg, volatile.LoadUint32(&o.SLP_TIMER1.Reg)&^(0xffff)|value)
}
func (o *RTC_CNTL_Type) GetSLP_TIMER1_SLP_VAL_HI() uint32 {
	return volatile.LoadUint32(&o.SLP_TIMER1.Reg) & 0xffff
}
func (o *RTC_CNTL_Type) SetSLP_TIMER1_MAIN_TIMER_ALARM_EN(value uint32) {
	volatile.StoreUint32(&o.SLP_TIMER1.Reg, volatile.LoadUint32(&o.SLP_TIMER1.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetSLP_TIMER1_MAIN_TIMER_ALARM_EN() uint32 {
	return (volatile.LoadUint32(&o.SLP_TIMER1.Reg) & 0x10000) >> 16
}

// RTC_CNTL.TIME_UPDATE
func (o *RTC_CNTL_Type) SetTIME_UPDATE_TIME_VALID(value uint32) {
	volatile.StoreUint32(&o.TIME_UPDATE.Reg, volatile.LoadUint32(&o.TIME_UPDATE.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetTIME_UPDATE_TIME_VALID() uint32 {
	return (volatile.LoadUint32(&o.TIME_UPDATE.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetTIME_UPDATE(value uint32) {
	volatile.StoreUint32(&o.TIME_UPDATE.Reg, volatile.LoadUint32(&o.TIME_UPDATE.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetTIME_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.TIME_UPDATE.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.TIME0
func (o *RTC_CNTL_Type) SetTIME0(value uint32) {
	volatile.StoreUint32(&o.TIME0.Reg, value)
}
func (o *RTC_CNTL_Type) GetTIME0() uint32 {
	return volatile.LoadUint32(&o.TIME0.Reg)
}

// RTC_CNTL.TIME1
func (o *RTC_CNTL_Type) SetTIME1_TIME_HI(value uint32) {
	volatile.StoreUint32(&o.TIME1.Reg, volatile.LoadUint32(&o.TIME1.Reg)&^(0xffff)|value)
}
func (o *RTC_CNTL_Type) GetTIME1_TIME_HI() uint32 {
	return volatile.LoadUint32(&o.TIME1.Reg) & 0xffff
}

// RTC_CNTL.STATE0
func (o *RTC_CNTL_Type) SetSTATE0_TOUCH_WAKEUP_FORCE_EN(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_CNTL_Type) GetSTATE0_TOUCH_WAKEUP_FORCE_EN() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0x100000) >> 20
}
func (o *RTC_CNTL_Type) SetSTATE0_ULP_CP_WAKEUP_FORCE_EN(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x200000)|value<<21)
}
func (o *RTC_CNTL_Type) GetSTATE0_ULP_CP_WAKEUP_FORCE_EN() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0x200000) >> 21
}
func (o *RTC_CNTL_Type) SetSTATE0_APB2RTC_BRIDGE_SEL(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_CNTL_Type) GetSTATE0_APB2RTC_BRIDGE_SEL() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0x400000) >> 22
}
func (o *RTC_CNTL_Type) SetSTATE0_TOUCH_SLP_TIMER_EN(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_CNTL_Type) GetSTATE0_TOUCH_SLP_TIMER_EN() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0x800000) >> 23
}
func (o *RTC_CNTL_Type) SetSTATE0_ULP_CP_SLP_TIMER_EN(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetSTATE0_ULP_CP_SLP_TIMER_EN() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0x1000000) >> 24
}
func (o *RTC_CNTL_Type) SetSTATE0_SDIO_ACTIVE_IND(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetSTATE0_SDIO_ACTIVE_IND() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0x10000000) >> 28
}
func (o *RTC_CNTL_Type) SetSTATE0_SLP_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetSTATE0_SLP_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetSTATE0_SLP_REJECT(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetSTATE0_SLP_REJECT() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetSTATE0_SLEEP_EN(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetSTATE0_SLEEP_EN() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.TIMER1
func (o *RTC_CNTL_Type) SetTIMER1_CPU_STALL_EN(value uint32) {
	volatile.StoreUint32(&o.TIMER1.Reg, volatile.LoadUint32(&o.TIMER1.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetTIMER1_CPU_STALL_EN() uint32 {
	return volatile.LoadUint32(&o.TIMER1.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetTIMER1_CPU_STALL_WAIT(value uint32) {
	volatile.StoreUint32(&o.TIMER1.Reg, volatile.LoadUint32(&o.TIMER1.Reg)&^(0x3e)|value<<1)
}
func (o *RTC_CNTL_Type) GetTIMER1_CPU_STALL_WAIT() uint32 {
	return (volatile.LoadUint32(&o.TIMER1.Reg) & 0x3e) >> 1
}
func (o *RTC_CNTL_Type) SetTIMER1_CK8M_WAIT(value uint32) {
	volatile.StoreUint32(&o.TIMER1.Reg, volatile.LoadUint32(&o.TIMER1.Reg)&^(0x3fc0)|value<<6)
}
func (o *RTC_CNTL_Type) GetTIMER1_CK8M_WAIT() uint32 {
	return (volatile.LoadUint32(&o.TIMER1.Reg) & 0x3fc0) >> 6
}
func (o *RTC_CNTL_Type) SetTIMER1_XTL_BUF_WAIT(value uint32) {
	volatile.StoreUint32(&o.TIMER1.Reg, volatile.LoadUint32(&o.TIMER1.Reg)&^(0xffc000)|value<<14)
}
func (o *RTC_CNTL_Type) GetTIMER1_XTL_BUF_WAIT() uint32 {
	return (volatile.LoadUint32(&o.TIMER1.Reg) & 0xffc000) >> 14
}
func (o *RTC_CNTL_Type) SetTIMER1_PLL_BUF_WAIT(value uint32) {
	volatile.StoreUint32(&o.TIMER1.Reg, volatile.LoadUint32(&o.TIMER1.Reg)&^(0xff000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetTIMER1_PLL_BUF_WAIT() uint32 {
	return (volatile.LoadUint32(&o.TIMER1.Reg) & 0xff000000) >> 24
}

// RTC_CNTL.TIMER2
func (o *RTC_CNTL_Type) SetTIMER2_ULPCP_TOUCH_START_WAIT(value uint32) {
	volatile.StoreUint32(&o.TIMER2.Reg, volatile.LoadUint32(&o.TIMER2.Reg)&^(0xff8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetTIMER2_ULPCP_TOUCH_START_WAIT() uint32 {
	return (volatile.LoadUint32(&o.TIMER2.Reg) & 0xff8000) >> 15
}
func (o *RTC_CNTL_Type) SetTIMER2_MIN_TIME_CK8M_OFF(value uint32) {
	volatile.StoreUint32(&o.TIMER2.Reg, volatile.LoadUint32(&o.TIMER2.Reg)&^(0xff000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetTIMER2_MIN_TIME_CK8M_OFF() uint32 {
	return (volatile.LoadUint32(&o.TIMER2.Reg) & 0xff000000) >> 24
}

// RTC_CNTL.TIMER3
func (o *RTC_CNTL_Type) SetTIMER3_WIFI_WAIT_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER3.Reg, volatile.LoadUint32(&o.TIMER3.Reg)&^(0x1ff)|value)
}
func (o *RTC_CNTL_Type) GetTIMER3_WIFI_WAIT_TIMER() uint32 {
	return volatile.LoadUint32(&o.TIMER3.Reg) & 0x1ff
}
func (o *RTC_CNTL_Type) SetTIMER3_WIFI_POWERUP_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER3.Reg, volatile.LoadUint32(&o.TIMER3.Reg)&^(0xfe00)|value<<9)
}
func (o *RTC_CNTL_Type) GetTIMER3_WIFI_POWERUP_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER3.Reg) & 0xfe00) >> 9
}
func (o *RTC_CNTL_Type) SetTIMER3_ROM_RAM_WAIT_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER3.Reg, volatile.LoadUint32(&o.TIMER3.Reg)&^(0x1ff0000)|value<<16)
}
func (o *RTC_CNTL_Type) GetTIMER3_ROM_RAM_WAIT_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER3.Reg) & 0x1ff0000) >> 16
}
func (o *RTC_CNTL_Type) SetTIMER3_ROM_RAM_POWERUP_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER3.Reg, volatile.LoadUint32(&o.TIMER3.Reg)&^(0xfe000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetTIMER3_ROM_RAM_POWERUP_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER3.Reg) & 0xfe000000) >> 25
}

// RTC_CNTL.TIMER4
func (o *RTC_CNTL_Type) SetTIMER4_WAIT_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER4.Reg, volatile.LoadUint32(&o.TIMER4.Reg)&^(0x1ff)|value)
}
func (o *RTC_CNTL_Type) GetTIMER4_WAIT_TIMER() uint32 {
	return volatile.LoadUint32(&o.TIMER4.Reg) & 0x1ff
}
func (o *RTC_CNTL_Type) SetTIMER4_POWERUP_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER4.Reg, volatile.LoadUint32(&o.TIMER4.Reg)&^(0xfe00)|value<<9)
}
func (o *RTC_CNTL_Type) GetTIMER4_POWERUP_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER4.Reg) & 0xfe00) >> 9
}
func (o *RTC_CNTL_Type) SetTIMER4_DG_WRAP_WAIT_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER4.Reg, volatile.LoadUint32(&o.TIMER4.Reg)&^(0x1ff0000)|value<<16)
}
func (o *RTC_CNTL_Type) GetTIMER4_DG_WRAP_WAIT_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER4.Reg) & 0x1ff0000) >> 16
}
func (o *RTC_CNTL_Type) SetTIMER4_DG_WRAP_POWERUP_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER4.Reg, volatile.LoadUint32(&o.TIMER4.Reg)&^(0xfe000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetTIMER4_DG_WRAP_POWERUP_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER4.Reg) & 0xfe000000) >> 25
}

// RTC_CNTL.TIMER5
func (o *RTC_CNTL_Type) SetTIMER5_ULP_CP_SUBTIMER_PREDIV(value uint32) {
	volatile.StoreUint32(&o.TIMER5.Reg, volatile.LoadUint32(&o.TIMER5.Reg)&^(0xff)|value)
}
func (o *RTC_CNTL_Type) GetTIMER5_ULP_CP_SUBTIMER_PREDIV() uint32 {
	return volatile.LoadUint32(&o.TIMER5.Reg) & 0xff
}
func (o *RTC_CNTL_Type) SetTIMER5_MIN_SLP_VAL(value uint32) {
	volatile.StoreUint32(&o.TIMER5.Reg, volatile.LoadUint32(&o.TIMER5.Reg)&^(0xff00)|value<<8)
}
func (o *RTC_CNTL_Type) GetTIMER5_MIN_SLP_VAL() uint32 {
	return (volatile.LoadUint32(&o.TIMER5.Reg) & 0xff00) >> 8
}
func (o *RTC_CNTL_Type) SetTIMER5_RTCMEM_WAIT_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER5.Reg, volatile.LoadUint32(&o.TIMER5.Reg)&^(0x1ff0000)|value<<16)
}
func (o *RTC_CNTL_Type) GetTIMER5_RTCMEM_WAIT_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER5.Reg) & 0x1ff0000) >> 16
}
func (o *RTC_CNTL_Type) SetTIMER5_RTCMEM_POWERUP_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER5.Reg, volatile.LoadUint32(&o.TIMER5.Reg)&^(0xfe000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetTIMER5_RTCMEM_POWERUP_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER5.Reg) & 0xfe000000) >> 25
}

// RTC_CNTL.ANA_CONF
func (o *RTC_CNTL_Type) SetANA_CONF_PLLA_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_CNTL_Type) GetANA_CONF_PLLA_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x800000) >> 23
}
func (o *RTC_CNTL_Type) SetANA_CONF_PLLA_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetANA_CONF_PLLA_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x1000000) >> 24
}
func (o *RTC_CNTL_Type) SetANA_CONF_BBPLL_CAL_SLP_START(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x2000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetANA_CONF_BBPLL_CAL_SLP_START() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x2000000) >> 25
}
func (o *RTC_CNTL_Type) SetANA_CONF_PVTMON_PU(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetANA_CONF_PVTMON_PU() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x4000000) >> 26
}
func (o *RTC_CNTL_Type) SetANA_CONF_TXRF_I2C_PU(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x8000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetANA_CONF_TXRF_I2C_PU() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x8000000) >> 27
}
func (o *RTC_CNTL_Type) SetANA_CONF_RFRX_PBUS_PU(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetANA_CONF_RFRX_PBUS_PU() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x10000000) >> 28
}
func (o *RTC_CNTL_Type) SetANA_CONF_CKGEN_I2C_PU(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetANA_CONF_CKGEN_I2C_PU() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetANA_CONF_PLL_I2C_PU(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetANA_CONF_PLL_I2C_PU() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.RESET_STATE
func (o *RTC_CNTL_Type) SetRESET_STATE_RESET_CAUSE_PROCPU(value uint32) {
	volatile.StoreUint32(&o.RESET_STATE.Reg, volatile.LoadUint32(&o.RESET_STATE.Reg)&^(0x3f)|value)
}
func (o *RTC_CNTL_Type) GetRESET_STATE_RESET_CAUSE_PROCPU() uint32 {
	return volatile.LoadUint32(&o.RESET_STATE.Reg) & 0x3f
}
func (o *RTC_CNTL_Type) SetRESET_STATE_RESET_CAUSE_APPCPU(value uint32) {
	volatile.StoreUint32(&o.RESET_STATE.Reg, volatile.LoadUint32(&o.RESET_STATE.Reg)&^(0xfc0)|value<<6)
}
func (o *RTC_CNTL_Type) GetRESET_STATE_RESET_CAUSE_APPCPU() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATE.Reg) & 0xfc0) >> 6
}
func (o *RTC_CNTL_Type) SetRESET_STATE_APPCPU_STAT_VECTOR_SEL(value uint32) {
	volatile.StoreUint32(&o.RESET_STATE.Reg, volatile.LoadUint32(&o.RESET_STATE.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetRESET_STATE_APPCPU_STAT_VECTOR_SEL() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATE.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetRESET_STATE_PROCPU_STAT_VECTOR_SEL(value uint32) {
	volatile.StoreUint32(&o.RESET_STATE.Reg, volatile.LoadUint32(&o.RESET_STATE.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetRESET_STATE_PROCPU_STAT_VECTOR_SEL() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATE.Reg) & 0x2000) >> 13
}

// RTC_CNTL.WAKEUP_STATE
func (o *RTC_CNTL_Type) SetWAKEUP_STATE_WAKEUP_CAUSE(value uint32) {
	volatile.StoreUint32(&o.WAKEUP_STATE.Reg, volatile.LoadUint32(&o.WAKEUP_STATE.Reg)&^(0x7ff)|value)
}
func (o *RTC_CNTL_Type) GetWAKEUP_STATE_WAKEUP_CAUSE() uint32 {
	return volatile.LoadUint32(&o.WAKEUP_STATE.Reg) & 0x7ff
}
func (o *RTC_CNTL_Type) SetWAKEUP_STATE_WAKEUP_ENA(value uint32) {
	volatile.StoreUint32(&o.WAKEUP_STATE.Reg, volatile.LoadUint32(&o.WAKEUP_STATE.Reg)&^(0x3ff800)|value<<11)
}
func (o *RTC_CNTL_Type) GetWAKEUP_STATE_WAKEUP_ENA() uint32 {
	return (volatile.LoadUint32(&o.WAKEUP_STATE.Reg) & 0x3ff800) >> 11
}
func (o *RTC_CNTL_Type) SetWAKEUP_STATE_GPIO_WAKEUP_FILTER(value uint32) {
	volatile.StoreUint32(&o.WAKEUP_STATE.Reg, volatile.LoadUint32(&o.WAKEUP_STATE.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_CNTL_Type) GetWAKEUP_STATE_GPIO_WAKEUP_FILTER() uint32 {
	return (volatile.LoadUint32(&o.WAKEUP_STATE.Reg) & 0x400000) >> 22
}

// RTC_CNTL.INT_ENA
func (o *RTC_CNTL_Type) SetINT_ENA_SLP_WAKEUP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetINT_ENA_SLP_WAKEUP_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetINT_ENA_SLP_REJECT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *RTC_CNTL_Type) GetINT_ENA_SLP_REJECT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *RTC_CNTL_Type) SetINT_ENA_SDIO_IDLE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *RTC_CNTL_Type) GetINT_ENA_SDIO_IDLE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}
func (o *RTC_CNTL_Type) SetINT_ENA_WDT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *RTC_CNTL_Type) GetINT_ENA_WDT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8) >> 3
}
func (o *RTC_CNTL_Type) SetINT_ENA_TIME_VALID_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetINT_ENA_TIME_VALID_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetINT_ENA_ULP_CP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetINT_ENA_ULP_CP_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetINT_ENA_TOUCH_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetINT_ENA_TOUCH_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetINT_ENA_BROWN_OUT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetINT_ENA_BROWN_OUT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetINT_ENA_MAIN_TIMER_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetINT_ENA_MAIN_TIMER_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x100) >> 8
}

// RTC_CNTL.INT_RAW
func (o *RTC_CNTL_Type) SetINT_RAW_SLP_WAKEUP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetINT_RAW_SLP_WAKEUP_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetINT_RAW_SLP_REJECT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *RTC_CNTL_Type) GetINT_RAW_SLP_REJECT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *RTC_CNTL_Type) SetINT_RAW_SDIO_IDLE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *RTC_CNTL_Type) GetINT_RAW_SDIO_IDLE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}
func (o *RTC_CNTL_Type) SetINT_RAW_WDT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *RTC_CNTL_Type) GetINT_RAW_WDT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8) >> 3
}
func (o *RTC_CNTL_Type) SetINT_RAW_TIME_VALID_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetINT_RAW_TIME_VALID_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetINT_RAW_ULP_CP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetINT_RAW_ULP_CP_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetINT_RAW_TOUCH_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetINT_RAW_TOUCH_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetINT_RAW_BROWN_OUT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetINT_RAW_BROWN_OUT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetINT_RAW_MAIN_TIMER_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetINT_RAW_MAIN_TIMER_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x100) >> 8
}

// RTC_CNTL.INT_ST
func (o *RTC_CNTL_Type) SetINT_ST_SLP_WAKEUP_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetINT_ST_SLP_WAKEUP_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetINT_ST_SLP_REJECT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *RTC_CNTL_Type) GetINT_ST_SLP_REJECT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2) >> 1
}
func (o *RTC_CNTL_Type) SetINT_ST_SDIO_IDLE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *RTC_CNTL_Type) GetINT_ST_SDIO_IDLE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4) >> 2
}
func (o *RTC_CNTL_Type) SetINT_ST_WDT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *RTC_CNTL_Type) GetINT_ST_WDT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8) >> 3
}
func (o *RTC_CNTL_Type) SetINT_ST_TIME_VALID_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetINT_ST_TIME_VALID_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetINT_ST_SAR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetINT_ST_SAR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetINT_ST_TOUCH_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetINT_ST_TOUCH_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetINT_ST_BROWN_OUT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetINT_ST_BROWN_OUT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetINT_ST_MAIN_TIMER_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetINT_ST_MAIN_TIMER_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x100) >> 8
}

// RTC_CNTL.INT_CLR
func (o *RTC_CNTL_Type) SetINT_CLR_SLP_WAKEUP_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetINT_CLR_SLP_WAKEUP_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetINT_CLR_SLP_REJECT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_CNTL_Type) GetINT_CLR_SLP_REJECT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *RTC_CNTL_Type) SetINT_CLR_SDIO_IDLE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_CNTL_Type) GetINT_CLR_SDIO_IDLE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}
func (o *RTC_CNTL_Type) SetINT_CLR_WDT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_CNTL_Type) GetINT_CLR_WDT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8) >> 3
}
func (o *RTC_CNTL_Type) SetINT_CLR_TIME_VALID_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetINT_CLR_TIME_VALID_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetINT_CLR_SAR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetINT_CLR_SAR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetINT_CLR_TOUCH_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetINT_CLR_TOUCH_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetINT_CLR_BROWN_OUT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetINT_CLR_BROWN_OUT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetINT_CLR_MAIN_TIMER_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetINT_CLR_MAIN_TIMER_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x100) >> 8
}

// RTC_CNTL.STORE0
func (o *RTC_CNTL_Type) SetSTORE0(value uint32) {
	volatile.StoreUint32(&o.STORE0.Reg, value)
}
func (o *RTC_CNTL_Type) GetSTORE0() uint32 {
	return volatile.LoadUint32(&o.STORE0.Reg)
}

// RTC_CNTL.STORE1
func (o *RTC_CNTL_Type) SetSTORE1(value uint32) {
	volatile.StoreUint32(&o.STORE1.Reg, value)
}
func (o *RTC_CNTL_Type) GetSTORE1() uint32 {
	return volatile.LoadUint32(&o.STORE1.Reg)
}

// RTC_CNTL.STORE2
func (o *RTC_CNTL_Type) SetSTORE2(value uint32) {
	volatile.StoreUint32(&o.STORE2.Reg, value)
}
func (o *RTC_CNTL_Type) GetSTORE2() uint32 {
	return volatile.LoadUint32(&o.STORE2.Reg)
}

// RTC_CNTL.STORE3
func (o *RTC_CNTL_Type) SetSTORE3(value uint32) {
	volatile.StoreUint32(&o.STORE3.Reg, value)
}
func (o *RTC_CNTL_Type) GetSTORE3() uint32 {
	return volatile.LoadUint32(&o.STORE3.Reg)
}

// RTC_CNTL.EXT_XTL_CONF
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_XTL_EXT_CTR_LV(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_XTL_EXT_CTR_LV() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_XTL_EXT_CTR_EN(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_XTL_EXT_CTR_EN() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.EXT_WAKEUP_CONF
func (o *RTC_CNTL_Type) SetEXT_WAKEUP_CONF_EXT_WAKEUP0_LV(value uint32) {
	volatile.StoreUint32(&o.EXT_WAKEUP_CONF.Reg, volatile.LoadUint32(&o.EXT_WAKEUP_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetEXT_WAKEUP_CONF_EXT_WAKEUP0_LV() uint32 {
	return (volatile.LoadUint32(&o.EXT_WAKEUP_CONF.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetEXT_WAKEUP_CONF_EXT_WAKEUP1_LV(value uint32) {
	volatile.StoreUint32(&o.EXT_WAKEUP_CONF.Reg, volatile.LoadUint32(&o.EXT_WAKEUP_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetEXT_WAKEUP_CONF_EXT_WAKEUP1_LV() uint32 {
	return (volatile.LoadUint32(&o.EXT_WAKEUP_CONF.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.SLP_REJECT_CONF
func (o *RTC_CNTL_Type) SetSLP_REJECT_CONF_GPIO_REJECT_EN(value uint32) {
	volatile.StoreUint32(&o.SLP_REJECT_CONF.Reg, volatile.LoadUint32(&o.SLP_REJECT_CONF.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetSLP_REJECT_CONF_GPIO_REJECT_EN() uint32 {
	return (volatile.LoadUint32(&o.SLP_REJECT_CONF.Reg) & 0x1000000) >> 24
}
func (o *RTC_CNTL_Type) SetSLP_REJECT_CONF_SDIO_REJECT_EN(value uint32) {
	volatile.StoreUint32(&o.SLP_REJECT_CONF.Reg, volatile.LoadUint32(&o.SLP_REJECT_CONF.Reg)&^(0x2000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetSLP_REJECT_CONF_SDIO_REJECT_EN() uint32 {
	return (volatile.LoadUint32(&o.SLP_REJECT_CONF.Reg) & 0x2000000) >> 25
}
func (o *RTC_CNTL_Type) SetSLP_REJECT_CONF_LIGHT_SLP_REJECT_EN(value uint32) {
	volatile.StoreUint32(&o.SLP_REJECT_CONF.Reg, volatile.LoadUint32(&o.SLP_REJECT_CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetSLP_REJECT_CONF_LIGHT_SLP_REJECT_EN() uint32 {
	return (volatile.LoadUint32(&o.SLP_REJECT_CONF.Reg) & 0x4000000) >> 26
}
func (o *RTC_CNTL_Type) SetSLP_REJECT_CONF_DEEP_SLP_REJECT_EN(value uint32) {
	volatile.StoreUint32(&o.SLP_REJECT_CONF.Reg, volatile.LoadUint32(&o.SLP_REJECT_CONF.Reg)&^(0x8000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetSLP_REJECT_CONF_DEEP_SLP_REJECT_EN() uint32 {
	return (volatile.LoadUint32(&o.SLP_REJECT_CONF.Reg) & 0x8000000) >> 27
}
func (o *RTC_CNTL_Type) SetSLP_REJECT_CONF_REJECT_CAUSE(value uint32) {
	volatile.StoreUint32(&o.SLP_REJECT_CONF.Reg, volatile.LoadUint32(&o.SLP_REJECT_CONF.Reg)&^(0xf0000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetSLP_REJECT_CONF_REJECT_CAUSE() uint32 {
	return (volatile.LoadUint32(&o.SLP_REJECT_CONF.Reg) & 0xf0000000) >> 28
}

// RTC_CNTL.CPU_PERIOD_CONF
func (o *RTC_CNTL_Type) SetCPU_PERIOD_CONF_CPUSEL_CONF(value uint32) {
	volatile.StoreUint32(&o.CPU_PERIOD_CONF.Reg, volatile.LoadUint32(&o.CPU_PERIOD_CONF.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetCPU_PERIOD_CONF_CPUSEL_CONF() uint32 {
	return (volatile.LoadUint32(&o.CPU_PERIOD_CONF.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetCPU_PERIOD_CONF_CPUPERIOD_SEL(value uint32) {
	volatile.StoreUint32(&o.CPU_PERIOD_CONF.Reg, volatile.LoadUint32(&o.CPU_PERIOD_CONF.Reg)&^(0xc0000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetCPU_PERIOD_CONF_CPUPERIOD_SEL() uint32 {
	return (volatile.LoadUint32(&o.CPU_PERIOD_CONF.Reg) & 0xc0000000) >> 30
}

// RTC_CNTL.SDIO_ACT_CONF
func (o *RTC_CNTL_Type) SetSDIO_ACT_CONF_SDIO_ACT_DNUM(value uint32) {
	volatile.StoreUint32(&o.SDIO_ACT_CONF.Reg, volatile.LoadUint32(&o.SDIO_ACT_CONF.Reg)&^(0xffc00000)|value<<22)
}
func (o *RTC_CNTL_Type) GetSDIO_ACT_CONF_SDIO_ACT_DNUM() uint32 {
	return (volatile.LoadUint32(&o.SDIO_ACT_CONF.Reg) & 0xffc00000) >> 22
}

// RTC_CNTL.CLK_CONF
func (o *RTC_CNTL_Type) SetCLK_CONF_CK8M_DIV(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x30)|value<<4)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_CK8M_DIV() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x30) >> 4
}
func (o *RTC_CNTL_Type) SetCLK_CONF_ENB_CK8M(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_ENB_CK8M() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetCLK_CONF_ENB_CK8M_DIV(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_ENB_CK8M_DIV() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetCLK_CONF_DIG_XTAL32K_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_DIG_XTAL32K_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetCLK_CONF_DIG_CLK8M_D256_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_DIG_CLK8M_D256_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetCLK_CONF_DIG_CLK8M_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_DIG_CLK8M_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetCLK_CONF_CK8M_DFREQ_FORCE(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_CK8M_DFREQ_FORCE() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetCLK_CONF_CK8M_DIV_SEL(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x7000)|value<<12)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_CK8M_DIV_SEL() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x7000) >> 12
}
func (o *RTC_CNTL_Type) SetCLK_CONF_XTAL_FORCE_NOGATING(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_XTAL_FORCE_NOGATING() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetCLK_CONF_CK8M_FORCE_NOGATING(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_CK8M_FORCE_NOGATING() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetCLK_CONF_CK8M_DFREQ(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x1fe0000)|value<<17)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_CK8M_DFREQ() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x1fe0000) >> 17
}
func (o *RTC_CNTL_Type) SetCLK_CONF_CK8M_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x2000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_CK8M_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x2000000) >> 25
}
func (o *RTC_CNTL_Type) SetCLK_CONF_CK8M_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_CK8M_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x4000000) >> 26
}
func (o *RTC_CNTL_Type) SetCLK_CONF_SOC_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x18000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_SOC_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x18000000) >> 27
}
func (o *RTC_CNTL_Type) SetCLK_CONF_FAST_CLK_RTC_SEL(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_FAST_CLK_RTC_SEL() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetCLK_CONF_ANA_CLK_RTC_SEL(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0xc0000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_ANA_CLK_RTC_SEL() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0xc0000000) >> 30
}

// RTC_CNTL.SDIO_CONF
func (o *RTC_CNTL_Type) SetSDIO_CONF_SDIO_PD_EN(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x200000)|value<<21)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_SDIO_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x200000) >> 21
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_SDIO_FORCE(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_SDIO_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x400000) >> 22
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_SDIO_TIEH(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_SDIO_TIEH() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x800000) >> 23
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_REG1P8_READY(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_REG1P8_READY() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x1000000) >> 24
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_DREFL_SDIO(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x6000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_DREFL_SDIO() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x6000000) >> 25
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_DREFM_SDIO(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x18000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_DREFM_SDIO() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x18000000) >> 27
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_DREFH_SDIO(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x60000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_DREFH_SDIO() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x60000000) >> 29
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_XPD_SDIO(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_XPD_SDIO() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.BIAS_CONF
func (o *RTC_CNTL_Type) SetBIAS_CONF_DBG_ATTEN(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x3000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_DBG_ATTEN() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x3000000) >> 24
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_ENB_SCK_XTAL(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_ENB_SCK_XTAL() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x4000000) >> 26
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_INC_HEARTBEAT_REFRESH(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x8000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_INC_HEARTBEAT_REFRESH() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x8000000) >> 27
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_DEC_HEARTBEAT_PERIOD(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_DEC_HEARTBEAT_PERIOD() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x10000000) >> 28
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_INC_HEARTBEAT_PERIOD(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_INC_HEARTBEAT_PERIOD() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_DEC_HEARTBEAT_WIDTH(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_DEC_HEARTBEAT_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_RST_BIAS_I2C(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_RST_BIAS_I2C() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.REG
func (o *RTC_CNTL_Type) SetREG_SCK_DCAP_FORCE(value uint32) {
	volatile.StoreUint32(&o.REG.Reg, volatile.LoadUint32(&o.REG.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetREG_SCK_DCAP_FORCE() uint32 {
	return (volatile.LoadUint32(&o.REG.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetREG_DIG_DBIAS_SLP(value uint32) {
	volatile.StoreUint32(&o.REG.Reg, volatile.LoadUint32(&o.REG.Reg)&^(0x700)|value<<8)
}
func (o *RTC_CNTL_Type) GetREG_DIG_DBIAS_SLP() uint32 {
	return (volatile.LoadUint32(&o.REG.Reg) & 0x700) >> 8
}
func (o *RTC_CNTL_Type) SetREG_DIG_DBIAS_WAK(value uint32) {
	volatile.StoreUint32(&o.REG.Reg, volatile.LoadUint32(&o.REG.Reg)&^(0x3800)|value<<11)
}
func (o *RTC_CNTL_Type) GetREG_DIG_DBIAS_WAK() uint32 {
	return (volatile.LoadUint32(&o.REG.Reg) & 0x3800) >> 11
}
func (o *RTC_CNTL_Type) SetREG_SCK_DCAP(value uint32) {
	volatile.StoreUint32(&o.REG.Reg, volatile.LoadUint32(&o.REG.Reg)&^(0x3fc000)|value<<14)
}
func (o *RTC_CNTL_Type) GetREG_SCK_DCAP() uint32 {
	return (volatile.LoadUint32(&o.REG.Reg) & 0x3fc000) >> 14
}
func (o *RTC_CNTL_Type) SetREG_DBIAS_SLP(value uint32) {
	volatile.StoreUint32(&o.REG.Reg, volatile.LoadUint32(&o.REG.Reg)&^(0x1c00000)|value<<22)
}
func (o *RTC_CNTL_Type) GetREG_DBIAS_SLP() uint32 {
	return (volatile.LoadUint32(&o.REG.Reg) & 0x1c00000) >> 22
}
func (o *RTC_CNTL_Type) SetREG_DBIAS_WAK(value uint32) {
	volatile.StoreUint32(&o.REG.Reg, volatile.LoadUint32(&o.REG.Reg)&^(0xe000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetREG_DBIAS_WAK() uint32 {
	return (volatile.LoadUint32(&o.REG.Reg) & 0xe000000) >> 25
}
func (o *RTC_CNTL_Type) SetREG_DBOOST_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.REG.Reg, volatile.LoadUint32(&o.REG.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetREG_DBOOST_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.REG.Reg) & 0x10000000) >> 28
}
func (o *RTC_CNTL_Type) SetREG_DBOOST_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.REG.Reg, volatile.LoadUint32(&o.REG.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetREG_DBOOST_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.REG.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetREG_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.REG.Reg, volatile.LoadUint32(&o.REG.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetREG_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.REG.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetREG_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.REG.Reg, volatile.LoadUint32(&o.REG.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetREG_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.REG.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.PWC
func (o *RTC_CNTL_Type) SetPWC_FASTMEM_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetPWC_FASTMEM_FORCE_NOISO() uint32 {
	return volatile.LoadUint32(&o.PWC.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetPWC_FASTMEM_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x2)|value<<1)
}
func (o *RTC_CNTL_Type) GetPWC_FASTMEM_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x2) >> 1
}
func (o *RTC_CNTL_Type) SetPWC_SLOWMEM_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x4)|value<<2)
}
func (o *RTC_CNTL_Type) GetPWC_SLOWMEM_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x4) >> 2
}
func (o *RTC_CNTL_Type) SetPWC_SLOWMEM_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x8)|value<<3)
}
func (o *RTC_CNTL_Type) GetPWC_SLOWMEM_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x8) >> 3
}
func (o *RTC_CNTL_Type) SetPWC_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetPWC_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetPWC_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetPWC_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetPWC_FASTMEM_FOLW_CPU(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetPWC_FASTMEM_FOLW_CPU() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetPWC_FASTMEM_FORCE_LPD(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetPWC_FASTMEM_FORCE_LPD() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetPWC_FASTMEM_FORCE_LPU(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetPWC_FASTMEM_FORCE_LPU() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetPWC_SLOWMEM_FOLW_CPU(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetPWC_SLOWMEM_FOLW_CPU() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetPWC_SLOWMEM_FORCE_LPD(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetPWC_SLOWMEM_FORCE_LPD() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetPWC_SLOWMEM_FORCE_LPU(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetPWC_SLOWMEM_FORCE_LPU() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetPWC_FASTMEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetPWC_FASTMEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetPWC_FASTMEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetPWC_FASTMEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetPWC_FASTMEM_PD_EN(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetPWC_FASTMEM_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetPWC_SLOWMEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetPWC_SLOWMEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetPWC_SLOWMEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetPWC_SLOWMEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetPWC_SLOWMEM_PD_EN(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetPWC_SLOWMEM_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x20000) >> 17
}
func (o *RTC_CNTL_Type) SetPWC_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetPWC_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x40000) >> 18
}
func (o *RTC_CNTL_Type) SetPWC_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_CNTL_Type) GetPWC_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x80000) >> 19
}
func (o *RTC_CNTL_Type) SetPWC_PD_EN(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_CNTL_Type) GetPWC_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x100000) >> 20
}

// RTC_CNTL.DIG_PWC
func (o *RTC_CNTL_Type) SetDIG_PWC_LSLP_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x8)|value<<3)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_LSLP_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x8) >> 3
}
func (o *RTC_CNTL_Type) SetDIG_PWC_LSLP_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_LSLP_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetDIG_PWC_ROM0_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_ROM0_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetDIG_PWC_ROM0_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_ROM0_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM0_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM0_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM0_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM0_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM1_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM1_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM1_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM1_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM2_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM2_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM2_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM2_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM3_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM3_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM3_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM3_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM4_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM4_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM4_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM4_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetDIG_PWC_WIFI_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_WIFI_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x20000) >> 17
}
func (o *RTC_CNTL_Type) SetDIG_PWC_WIFI_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_WIFI_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x40000) >> 18
}
func (o *RTC_CNTL_Type) SetDIG_PWC_DG_WRAP_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_DG_WRAP_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x80000) >> 19
}
func (o *RTC_CNTL_Type) SetDIG_PWC_DG_WRAP_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_DG_WRAP_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x100000) >> 20
}
func (o *RTC_CNTL_Type) SetDIG_PWC_ROM0_PD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_ROM0_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x1000000) >> 24
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM0_PD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x2000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM0_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x2000000) >> 25
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM1_PD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM1_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x4000000) >> 26
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM2_PD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x8000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM2_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x8000000) >> 27
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM3_PD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM3_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x10000000) >> 28
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM4_PD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM4_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetDIG_PWC_WIFI_PD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_WIFI_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetDIG_PWC_DG_WRAP_PD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_DG_WRAP_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.DIG_ISO
func (o *RTC_CNTL_Type) SetDIG_ISO_FORCE_OFF(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_FORCE_OFF() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetDIG_ISO_FORCE_ON(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_FORCE_ON() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetDIG_ISO_DG_PAD_AUTOHOLD(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_DG_PAD_AUTOHOLD() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetDIG_ISO_CLR_DG_PAD_AUTOHOLD(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_CLR_DG_PAD_AUTOHOLD() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetDIG_ISO_DG_PAD_AUTOHOLD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_DG_PAD_AUTOHOLD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetDIG_ISO_DG_PAD_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_DG_PAD_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetDIG_ISO_DG_PAD_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_DG_PAD_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetDIG_ISO_DG_PAD_FORCE_UNHOLD(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_DG_PAD_FORCE_UNHOLD() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetDIG_ISO_DG_PAD_FORCE_HOLD(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_DG_PAD_FORCE_HOLD() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetDIG_ISO_ROM0_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_ROM0_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetDIG_ISO_ROM0_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_ROM0_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x20000) >> 17
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM0_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM0_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x40000) >> 18
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM0_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM0_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x80000) >> 19
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM1_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM1_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x100000) >> 20
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM1_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x200000)|value<<21)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM1_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x200000) >> 21
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM2_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM2_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x400000) >> 22
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM2_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM2_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x800000) >> 23
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM3_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM3_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x1000000) >> 24
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM3_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x2000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM3_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x2000000) >> 25
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM4_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM4_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x4000000) >> 26
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM4_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x8000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM4_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x8000000) >> 27
}
func (o *RTC_CNTL_Type) SetDIG_ISO_WIFI_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_WIFI_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x10000000) >> 28
}
func (o *RTC_CNTL_Type) SetDIG_ISO_WIFI_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_WIFI_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetDIG_ISO_DG_WRAP_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_DG_WRAP_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetDIG_ISO_DG_WRAP_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_DG_WRAP_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.WDTCONFIG0
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_PAUSE_IN_SLP(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_PAUSE_IN_SLP() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_APPCPU_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_APPCPU_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_PROCPU_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_PROCPU_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_FLASHBOOT_MOD_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_FLASHBOOT_MOD_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_SYS_RESET_LENGTH(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x3800)|value<<11)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_SYS_RESET_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x3800) >> 11
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_CPU_RESET_LENGTH(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x1c000)|value<<14)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_CPU_RESET_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x1c000) >> 14
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_LEVEL_INT_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_LEVEL_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x20000) >> 17
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_EDGE_INT_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_EDGE_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x40000) >> 18
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_STG3(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x380000)|value<<19)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_STG3() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x380000) >> 19
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_STG2(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x1c00000)|value<<22)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_STG2() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x1c00000) >> 22
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_STG1(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0xe000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_STG1() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0xe000000) >> 25
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_STG0(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x70000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_STG0() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x70000000) >> 28
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.WDTCONFIG1
func (o *RTC_CNTL_Type) SetWDTCONFIG1(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG1.Reg, value)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG1() uint32 {
	return volatile.LoadUint32(&o.WDTCONFIG1.Reg)
}

// RTC_CNTL.WDTCONFIG2
func (o *RTC_CNTL_Type) SetWDTCONFIG2(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG2.Reg, value)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG2() uint32 {
	return volatile.LoadUint32(&o.WDTCONFIG2.Reg)
}

// RTC_CNTL.WDTCONFIG3
func (o *RTC_CNTL_Type) SetWDTCONFIG3(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG3.Reg, value)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG3() uint32 {
	return volatile.LoadUint32(&o.WDTCONFIG3.Reg)
}

// RTC_CNTL.WDTCONFIG4
func (o *RTC_CNTL_Type) SetWDTCONFIG4(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG4.Reg, value)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG4() uint32 {
	return volatile.LoadUint32(&o.WDTCONFIG4.Reg)
}

// RTC_CNTL.WDTFEED
func (o *RTC_CNTL_Type) SetWDTFEED_WDT_FEED(value uint32) {
	volatile.StoreUint32(&o.WDTFEED.Reg, volatile.LoadUint32(&o.WDTFEED.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetWDTFEED_WDT_FEED() uint32 {
	return (volatile.LoadUint32(&o.WDTFEED.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.WDTWPROTECT
func (o *RTC_CNTL_Type) SetWDTWPROTECT(value uint32) {
	volatile.StoreUint32(&o.WDTWPROTECT.Reg, value)
}
func (o *RTC_CNTL_Type) GetWDTWPROTECT() uint32 {
	return volatile.LoadUint32(&o.WDTWPROTECT.Reg)
}

// RTC_CNTL.TEST_MUX
func (o *RTC_CNTL_Type) SetTEST_MUX_ENT_RTC(value uint32) {
	volatile.StoreUint32(&o.TEST_MUX.Reg, volatile.LoadUint32(&o.TEST_MUX.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetTEST_MUX_ENT_RTC() uint32 {
	return (volatile.LoadUint32(&o.TEST_MUX.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetTEST_MUX_DTEST_RTC(value uint32) {
	volatile.StoreUint32(&o.TEST_MUX.Reg, volatile.LoadUint32(&o.TEST_MUX.Reg)&^(0xc0000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetTEST_MUX_DTEST_RTC() uint32 {
	return (volatile.LoadUint32(&o.TEST_MUX.Reg) & 0xc0000000) >> 30
}

// RTC_CNTL.SW_CPU_STALL
func (o *RTC_CNTL_Type) SetSW_CPU_STALL_SW_STALL_APPCPU_C1(value uint32) {
	volatile.StoreUint32(&o.SW_CPU_STALL.Reg, volatile.LoadUint32(&o.SW_CPU_STALL.Reg)&^(0x3f00000)|value<<20)
}
func (o *RTC_CNTL_Type) GetSW_CPU_STALL_SW_STALL_APPCPU_C1() uint32 {
	return (volatile.LoadUint32(&o.SW_CPU_STALL.Reg) & 0x3f00000) >> 20
}
func (o *RTC_CNTL_Type) SetSW_CPU_STALL_SW_STALL_PROCPU_C1(value uint32) {
	volatile.StoreUint32(&o.SW_CPU_STALL.Reg, volatile.LoadUint32(&o.SW_CPU_STALL.Reg)&^(0xfc000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetSW_CPU_STALL_SW_STALL_PROCPU_C1() uint32 {
	return (volatile.LoadUint32(&o.SW_CPU_STALL.Reg) & 0xfc000000) >> 26
}

// RTC_CNTL.STORE4
func (o *RTC_CNTL_Type) SetSTORE4(value uint32) {
	volatile.StoreUint32(&o.STORE4.Reg, value)
}
func (o *RTC_CNTL_Type) GetSTORE4() uint32 {
	return volatile.LoadUint32(&o.STORE4.Reg)
}

// RTC_CNTL.STORE5
func (o *RTC_CNTL_Type) SetSTORE5(value uint32) {
	volatile.StoreUint32(&o.STORE5.Reg, value)
}
func (o *RTC_CNTL_Type) GetSTORE5() uint32 {
	return volatile.LoadUint32(&o.STORE5.Reg)
}

// RTC_CNTL.STORE6
func (o *RTC_CNTL_Type) SetSTORE6(value uint32) {
	volatile.StoreUint32(&o.STORE6.Reg, value)
}
func (o *RTC_CNTL_Type) GetSTORE6() uint32 {
	return volatile.LoadUint32(&o.STORE6.Reg)
}

// RTC_CNTL.STORE7
func (o *RTC_CNTL_Type) SetSTORE7(value uint32) {
	volatile.StoreUint32(&o.STORE7.Reg, value)
}
func (o *RTC_CNTL_Type) GetSTORE7() uint32 {
	return volatile.LoadUint32(&o.STORE7.Reg)
}

// RTC_CNTL.LOW_POWER_ST
func (o *RTC_CNTL_Type) SetLOW_POWER_ST(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, value)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST() uint32 {
	return volatile.LoadUint32(&o.LOW_POWER_ST.Reg)
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_RDY_FOR_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_RDY_FOR_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x80000) >> 19
}

// RTC_CNTL.DIAG1
func (o *RTC_CNTL_Type) SetDIAG1(value uint32) {
	volatile.StoreUint32(&o.DIAG1.Reg, value)
}
func (o *RTC_CNTL_Type) GetDIAG1() uint32 {
	return volatile.LoadUint32(&o.DIAG1.Reg)
}

// RTC_CNTL.HOLD_FORCE
func (o *RTC_CNTL_Type) SetHOLD_FORCE_ADC1_HOLD_FORCE(value uint32) {
	volatile.StoreUint32(&o.HOLD_FORCE.Reg, volatile.LoadUint32(&o.HOLD_FORCE.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetHOLD_FORCE_ADC1_HOLD_FORCE() uint32 {
	return volatile.LoadUint32(&o.HOLD_FORCE.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetHOLD_FORCE_ADC2_HOLD_FORCE(value uint32) {
	volatile.StoreUint32(&o.HOLD_FORCE.Reg, volatile.LoadUint32(&o.HOLD_FORCE.Reg)&^(0x2)|value<<1)
}
func (o *RTC_CNTL_Type) GetHOLD_FORCE_ADC2_HOLD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.HOLD_FORCE.Reg) & 0x2) >> 1
}
func (o *RTC_CNTL_Type) SetHOLD_FORCE_PDAC1_HOLD_FORCE(value uint32) {
	volatile.StoreUint32(&o.HOLD_FORCE.Reg, volatile.LoadUint32(&o.HOLD_FORCE.Reg)&^(0x4)|value<<2)
}
func (o *RTC_CNTL_Type) GetHOLD_FORCE_PDAC1_HOLD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.HOLD_FORCE.Reg) & 0x4) >> 2
}
func (o *RTC_CNTL_Type) SetHOLD_FORCE_PDAC2_HOLD_FORCE(value uint32) {
	volatile.StoreUint32(&o.HOLD_FORCE.Reg, volatile.LoadUint32(&o.HOLD_FORCE.Reg)&^(0x8)|value<<3)
}
func (o *RTC_CNTL_Type) GetHOLD_FORCE_PDAC2_HOLD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.HOLD_FORCE.Reg) & 0x8) >> 3
}
func (o *RTC_CNTL_Type) SetHOLD_FORCE_SENSE1_HOLD_FORCE(value uint32) {
	volatile.StoreUint32(&o.HOLD_FORCE.Reg, volatile.LoadUint32(&o.HOLD_FORCE.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetHOLD_FORCE_SENSE1_HOLD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.HOLD_FORCE.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetHOLD_FORCE_SENSE2_HOLD_FORCE(value uint32) {
	volatile.StoreUint32(&o.HOLD_FORCE.Reg, volatile.LoadUint32(&o.HOLD_FORCE.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetHOLD_FORCE_SENSE2_HOLD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.HOLD_FORCE.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetHOLD_FORCE_SENSE3_HOLD_FORCE(value uint32) {
	volatile.StoreUint32(&o.HOLD_FORCE.Reg, volatile.LoadUint32(&o.HOLD_FORCE.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetHOLD_FORCE_SENSE3_HOLD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.HOLD_FORCE.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetHOLD_FORCE_SENSE4_HOLD_FORCE(value uint32) {
	volatile.StoreUint32(&o.HOLD_FORCE.Reg, volatile.LoadUint32(&o.HOLD_FORCE.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetHOLD_FORCE_SENSE4_HOLD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.HOLD_FORCE.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetHOLD_FORCE_TOUCH_PAD0_HOLD_FORCE(value uint32) {
	volatile.StoreUint32(&o.HOLD_FORCE.Reg, volatile.LoadUint32(&o.HOLD_FORCE.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetHOLD_FORCE_TOUCH_PAD0_HOLD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.HOLD_FORCE.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetHOLD_FORCE_TOUCH_PAD1_HOLD_FORCE(value uint32) {
	volatile.StoreUint32(&o.HOLD_FORCE.Reg, volatile.LoadUint32(&o.HOLD_FORCE.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetHOLD_FORCE_TOUCH_PAD1_HOLD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.HOLD_FORCE.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetHOLD_FORCE_TOUCH_PAD2_HOLD_FORCE(value uint32) {
	volatile.StoreUint32(&o.HOLD_FORCE.Reg, volatile.LoadUint32(&o.HOLD_FORCE.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetHOLD_FORCE_TOUCH_PAD2_HOLD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.HOLD_FORCE.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetHOLD_FORCE_TOUCH_PAD3_HOLD_FORCE(value uint32) {
	volatile.StoreUint32(&o.HOLD_FORCE.Reg, volatile.LoadUint32(&o.HOLD_FORCE.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetHOLD_FORCE_TOUCH_PAD3_HOLD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.HOLD_FORCE.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetHOLD_FORCE_TOUCH_PAD4_HOLD_FORCE(value uint32) {
	volatile.StoreUint32(&o.HOLD_FORCE.Reg, volatile.LoadUint32(&o.HOLD_FORCE.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetHOLD_FORCE_TOUCH_PAD4_HOLD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.HOLD_FORCE.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetHOLD_FORCE_TOUCH_PAD5_HOLD_FORCE(value uint32) {
	volatile.StoreUint32(&o.HOLD_FORCE.Reg, volatile.LoadUint32(&o.HOLD_FORCE.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetHOLD_FORCE_TOUCH_PAD5_HOLD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.HOLD_FORCE.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetHOLD_FORCE_TOUCH_PAD6_HOLD_FORCE(value uint32) {
	volatile.StoreUint32(&o.HOLD_FORCE.Reg, volatile.LoadUint32(&o.HOLD_FORCE.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetHOLD_FORCE_TOUCH_PAD6_HOLD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.HOLD_FORCE.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetHOLD_FORCE_TOUCH_PAD7_HOLD_FORCE(value uint32) {
	volatile.StoreUint32(&o.HOLD_FORCE.Reg, volatile.LoadUint32(&o.HOLD_FORCE.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetHOLD_FORCE_TOUCH_PAD7_HOLD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.HOLD_FORCE.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetHOLD_FORCE_X32P_HOLD_FORCE(value uint32) {
	volatile.StoreUint32(&o.HOLD_FORCE.Reg, volatile.LoadUint32(&o.HOLD_FORCE.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetHOLD_FORCE_X32P_HOLD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.HOLD_FORCE.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetHOLD_FORCE_X32N_HOLD_FORCE(value uint32) {
	volatile.StoreUint32(&o.HOLD_FORCE.Reg, volatile.LoadUint32(&o.HOLD_FORCE.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetHOLD_FORCE_X32N_HOLD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.HOLD_FORCE.Reg) & 0x20000) >> 17
}

// RTC_CNTL.EXT_WAKEUP1
func (o *RTC_CNTL_Type) SetEXT_WAKEUP1_SEL(value uint32) {
	volatile.StoreUint32(&o.EXT_WAKEUP1.Reg, volatile.LoadUint32(&o.EXT_WAKEUP1.Reg)&^(0x3ffff)|value)
}
func (o *RTC_CNTL_Type) GetEXT_WAKEUP1_SEL() uint32 {
	return volatile.LoadUint32(&o.EXT_WAKEUP1.Reg) & 0x3ffff
}
func (o *RTC_CNTL_Type) SetEXT_WAKEUP1_STATUS_CLR(value uint32) {
	volatile.StoreUint32(&o.EXT_WAKEUP1.Reg, volatile.LoadUint32(&o.EXT_WAKEUP1.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetEXT_WAKEUP1_STATUS_CLR() uint32 {
	return (volatile.LoadUint32(&o.EXT_WAKEUP1.Reg) & 0x40000) >> 18
}

// RTC_CNTL.EXT_WAKEUP1_STATUS
func (o *RTC_CNTL_Type) SetEXT_WAKEUP1_STATUS(value uint32) {
	volatile.StoreUint32(&o.EXT_WAKEUP1_STATUS.Reg, volatile.LoadUint32(&o.EXT_WAKEUP1_STATUS.Reg)&^(0x3ffff)|value)
}
func (o *RTC_CNTL_Type) GetEXT_WAKEUP1_STATUS() uint32 {
	return volatile.LoadUint32(&o.EXT_WAKEUP1_STATUS.Reg) & 0x3ffff
}

// RTC_CNTL.BROWN_OUT
func (o *RTC_CNTL_Type) SetBROWN_OUT_RTC_MEM_PID_CONF(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0xff)|value)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_RTC_MEM_PID_CONF() uint32 {
	return volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0xff
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_RTC_MEM_CRC_START(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_RTC_MEM_CRC_START() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_RTC_MEM_CRC_ADDR(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0xffe00)|value<<9)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_RTC_MEM_CRC_ADDR() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0xffe00) >> 9
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_CLOSE_FLASH_ENA(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_CLOSE_FLASH_ENA() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_PD_RF_ENA(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_PD_RF_ENA() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_RST_WAIT(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x3ff0000)|value<<16)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_RST_WAIT() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x3ff0000) >> 16
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_RTC_MEM_CRC_LEN(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x7ff00000)|value<<20)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_RTC_MEM_CRC_LEN() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x7ff00000) >> 20
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_RST_ENA(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_RST_ENA() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x4000000) >> 26
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_DBROWN_OUT_THRES(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x38000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_DBROWN_OUT_THRES() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x38000000) >> 27
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_ENA(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_ENA() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_DET(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_DET() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x80000000) >> 31
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_RTC_MEM_CRC_FINISH(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_RTC_MEM_CRC_FINISH() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.DATE
func (o *RTC_CNTL_Type) SetDATE_CNTL_DATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *RTC_CNTL_Type) GetDATE_CNTL_DATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}
